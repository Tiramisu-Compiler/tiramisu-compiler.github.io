<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Tiramisu Compiler: tiramisu::computation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiramisu Compiler
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtiramisu_1_1computation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtiramisu_1_1computation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tiramisu::computation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that represents computations.  
 <a href="classtiramisu_1_1computation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_8h_source.html">core.h</a>&gt;</code></p>

<p>Inherited by <a class="el" href="classtiramisu_1_1communicator.html">tiramisu::communicator</a>, <a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a>, <a class="el" href="classtiramisu_1_1input.html">tiramisu::input</a>, and <a class="el" href="classtiramisu_1_1view.html">tiramisu::view</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a802535b5fb6144e54a83051f7b612b86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a802535b5fb6144e54a83051f7b612b86">computation</a> (std::string iteration_domain, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e, bool schedule_this_computation, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a> t, <a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *fct)</td></tr>
<tr class="memdesc:a802535b5fb6144e54a83051f7b612b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for computations.  <a href="#a802535b5fb6144e54a83051f7b612b86">More...</a><br /></td></tr>
<tr class="separator:a802535b5fb6144e54a83051f7b612b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccc96c6683e8c57bd53844ac7470996"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a2ccc96c6683e8c57bd53844ac7470996">computation</a> (std::string name, std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt; iterator_variables, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e, bool schedule_this_computation)</td></tr>
<tr class="memdesc:a2ccc96c6683e8c57bd53844ac7470996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for computations.  <a href="#a2ccc96c6683e8c57bd53844ac7470996">More...</a><br /></td></tr>
<tr class="separator:a2ccc96c6683e8c57bd53844ac7470996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf47e619e720940f071e78a425e621e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#abf47e619e720940f071e78a425e621e6">computation</a> (std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt; iterator_variables, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e)</td></tr>
<tr class="memdesc:abf47e619e720940f071e78a425e621e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#abf47e619e720940f071e78a425e621e6">More...</a><br /></td></tr>
<tr class="separator:abf47e619e720940f071e78a425e621e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e7897febc0bdabef7af09b8f236cdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ae1e7897febc0bdabef7af09b8f236cdf">computation</a> (std::string name, std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt; iterator_variables, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e)</td></tr>
<tr class="memdesc:ae1e7897febc0bdabef7af09b8f236cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for computations.  <a href="#ae1e7897febc0bdabef7af09b8f236cdf">More...</a><br /></td></tr>
<tr class="separator:ae1e7897febc0bdabef7af09b8f236cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4285634473bd55d0f9158e87babd8ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ad4285634473bd55d0f9158e87babd8ad">computation</a> (std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt; iterator_variables, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e, bool schedule_this_computation)</td></tr>
<tr class="memdesc:ad4285634473bd55d0f9158e87babd8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ad4285634473bd55d0f9158e87babd8ad">More...</a><br /></td></tr>
<tr class="separator:ad4285634473bd55d0f9158e87babd8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda461fdf0185f176ef6ae4957b3d536"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aeda461fdf0185f176ef6ae4957b3d536">computation</a> (std::string name, std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt; iterator_variables, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">primitive_t</a> t)</td></tr>
<tr class="memdesc:aeda461fdf0185f176ef6ae4957b3d536"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<code>t</code> is the type of the computation, i.e.  <a href="#aeda461fdf0185f176ef6ae4957b3d536">More...</a><br /></td></tr>
<tr class="separator:aeda461fdf0185f176ef6ae4957b3d536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c3eef364ae4d60ab836ebffcfed12c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a66c3eef364ae4d60ab836ebffcfed12c">computation</a> (std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt; iterator_variables, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">primitive_t</a> t)</td></tr>
<tr class="memdesc:a66c3eef364ae4d60ab836ebffcfed12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a66c3eef364ae4d60ab836ebffcfed12c">More...</a><br /></td></tr>
<tr class="separator:a66c3eef364ae4d60ab836ebffcfed12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253020596918f051ef183422858ea235"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a253020596918f051ef183422858ea235">is_send</a> () const </td></tr>
<tr class="separator:a253020596918f051ef183422858ea235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8df98d2b6894124bceec12a852aca31"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#af8df98d2b6894124bceec12a852aca31">is_recv</a> () const </td></tr>
<tr class="separator:af8df98d2b6894124bceec12a852aca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16655c34d71e6c5dd1e65f0b821e10ef"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a16655c34d71e6c5dd1e65f0b821e10ef">is_send_recv</a> () const </td></tr>
<tr class="separator:a16655c34d71e6c5dd1e65f0b821e10ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc6962d629ebb621db5b87c546a3041"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a1dc6962d629ebb621db5b87c546a3041">is_wait</a> () const </td></tr>
<tr class="separator:a1dc6962d629ebb621db5b87c546a3041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731631b840bb6853af793ecc8b96253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac731631b840bb6853af793ecc8b96253">add_associated_let_stmt</a> (std::string access_name, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e)</td></tr>
<tr class="memdesc:ac731631b840bb6853af793ecc8b96253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a let statement that is associated to this computation.  <a href="#ac731631b840bb6853af793ecc8b96253">More...</a><br /></td></tr>
<tr class="separator:ac731631b840bb6853af793ecc8b96253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afeafbe16b09b6b2a8f58d00ce3870b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7afeafbe16b09b6b2a8f58d00ce3870b">unschedule_this_computation</a> ()</td></tr>
<tr class="memdesc:a7afeafbe16b09b6b2a8f58d00ce3870b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't scheduled a previously scheduled computation.  <a href="#a7afeafbe16b09b6b2a8f58d00ce3870b">More...</a><br /></td></tr>
<tr class="separator:a7afeafbe16b09b6b2a8f58d00ce3870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbac0c76308eea25b37462028bff3c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a3bbac0c76308eea25b37462028bff3c4">add_definitions</a> (std::string iteration_domain_str, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e, bool schedule_this_computation, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a> t, <a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *fct)</td></tr>
<tr class="memdesc:a3bbac0c76308eea25b37462028bff3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add definitions of computations that have the same name as this computation.  <a href="#a3bbac0c76308eea25b37462028bff3c4">More...</a><br /></td></tr>
<tr class="separator:a3bbac0c76308eea25b37462028bff3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcd659e4fabb0cce1562e4c1fe326e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aadcd659e4fabb0cce1562e4c1fe326e7">add_predicate</a> (<a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> predicate)</td></tr>
<tr class="memdesc:aadcd659e4fabb0cce1562e4c1fe326e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a predicate (condition) on the computation.  <a href="#aadcd659e4fabb0cce1562e4c1fe326e7">More...</a><br /></td></tr>
<tr class="separator:aadcd659e4fabb0cce1562e4c1fe326e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27181748bece6f76f528982089951e0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d">after</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> iterator)</td></tr>
<tr class="memdesc:a27181748bece6f76f528982089951e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run after the computation <code>comp</code>.  <a href="#a27181748bece6f76f528982089951e0d">More...</a><br /></td></tr>
<tr class="separator:a27181748bece6f76f528982089951e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a37d6620871e18fb1df0a5a3bbb936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#af8a37d6620871e18fb1df0a5a3bbb936">after</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;comp, int level)</td></tr>
<tr class="memdesc:af8a37d6620871e18fb1df0a5a3bbb936"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is equivalent to void <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">after(computation &amp;comp, tiramisu::var iterator)</a>; except that it uses loop level numbers (0, 1, 2, ...) instead of using loop variables (<a class="el" href="classtiramisu_1_1var.html" title="A class that represents constant variable references. ">tiramisu::var</a>).  <a href="#af8a37d6620871e18fb1df0a5a3bbb936">More...</a><br /></td></tr>
<tr class="separator:af8a37d6620871e18fb1df0a5a3bbb936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff7cfc17026f57393b1c315a686f5cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aeff7cfc17026f57393b1c315a686f5cd">allocate_and_map_buffer_automatically</a> (<a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aed">tiramisu::argument_t</a> type=<a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aeda241ff08aa2bef135ac9f6691651244f5">tiramisu::a_temporary</a>)</td></tr>
<tr class="separator:aeff7cfc17026f57393b1c315a686f5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c50e1fde5b2ebc3e27575d10448769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a58c50e1fde5b2ebc3e27575d10448769">apply_transformation_on_schedule</a> (std::string map_str)</td></tr>
<tr class="memdesc:a58c50e1fde5b2ebc3e27575d10448769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a transformation on the schedule.  <a href="#a58c50e1fde5b2ebc3e27575d10448769">More...</a><br /></td></tr>
<tr class="separator:a58c50e1fde5b2ebc3e27575d10448769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc052433e6e1eb850e1df1f128986b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#acc052433e6e1eb850e1df1f128986b60">between</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;before_comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> before_l, <a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;after_comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> after_l)</td></tr>
<tr class="memdesc:acc052433e6e1eb850e1df1f128986b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run after <code>before_comp</code> at the loop level <code>before_l</code>, and before <code>after_comp</code> at loop level <code>after_l</code>.  <a href="#acc052433e6e1eb850e1df1f128986b60">More...</a><br /></td></tr>
<tr class="separator:acc052433e6e1eb850e1df1f128986b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc26ee002088f750f872e6747f9582cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#afc26ee002088f750f872e6747f9582cf">get_automatically_allocated_buffer</a> ()</td></tr>
<tr class="memdesc:afc26ee002088f750f872e6747f9582cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer that was allocated automatically using high level data mapping functions.  <a href="#afc26ee002088f750f872e6747f9582cf">More...</a><br /></td></tr>
<tr class="separator:afc26ee002088f750f872e6747f9582cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3370d2b63da2c87438a7d6da92afc0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a3370d2b63da2c87438a7d6da92afc0e5">interchange</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1)</td></tr>
<tr class="memdesc:a3370d2b63da2c87438a7d6da92afc0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchange (swap) the two loop levels <code>L0</code> and <code>L1</code>.  <a href="#a3370d2b63da2c87438a7d6da92afc0e5">More...</a><br /></td></tr>
<tr class="separator:a3370d2b63da2c87438a7d6da92afc0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8a259be046d45732ef4c723470fa89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a3a8a259be046d45732ef4c723470fa89">interchange</a> (int L0, int L1)</td></tr>
<tr class="memdesc:a3a8a259be046d45732ef4c723470fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to void <a class="el" href="classtiramisu_1_1computation.html#a3370d2b63da2c87438a7d6da92afc0e5" title="Interchange (swap) the two loop levels L0 and L1. ">interchange(tiramisu::var L0, tiramisu::var L1)</a>;.  <a href="#a3a8a259be046d45732ef4c723470fa89">More...</a><br /></td></tr>
<tr class="separator:a3a8a259be046d45732ef4c723470fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb92906d4541d1ab073bf9a164bc31c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a4bb92906d4541d1ab073bf9a164bc31c">mark_as_let_statement</a> ()</td></tr>
<tr class="memdesc:a4bb92906d4541d1ab073bf9a164bc31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this statement as a let statement.  <a href="#a4bb92906d4541d1ab073bf9a164bc31c">More...</a><br /></td></tr>
<tr class="separator:a4bb92906d4541d1ab073bf9a164bc31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af556bb9e098aaa4329981257ae45cf9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#af556bb9e098aaa4329981257ae45cf9a">mark_as_library_call</a> ()</td></tr>
<tr class="memdesc:af556bb9e098aaa4329981257ae45cf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this statement as a library call.  <a href="#af556bb9e098aaa4329981257ae45cf9a">More...</a><br /></td></tr>
<tr class="separator:af556bb9e098aaa4329981257ae45cf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c748331b7a5d0c111c1bb24928ec771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a0c748331b7a5d0c111c1bb24928ec771">parallelize</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:a0c748331b7a5d0c111c1bb24928ec771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be parallelized.  <a href="#a0c748331b7a5d0c111c1bb24928ec771">More...</a><br /></td></tr>
<tr class="separator:a0c748331b7a5d0c111c1bb24928ec771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c24a6e6da57ce6c9b885553c257bf70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a9c24a6e6da57ce6c9b885553c257bf70">set_wait_access</a> (std::string access_str)</td></tr>
<tr class="separator:a9c24a6e6da57ce6c9b885553c257bf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9e9e6c4ef9738717202db9e222d81a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7b9e9e6c4ef9738717202db9e222d81a">set_wait_access</a> (isl_map *access)</td></tr>
<tr class="separator:a7b9e9e6c4ef9738717202db9e222d81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5d65959a7499510d81a0bafe9a078d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#abc5d65959a7499510d81a0bafe9a078d">set_expression</a> (const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &amp;e)</td></tr>
<tr class="memdesc:abc5d65959a7499510d81a0bafe9a078d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the expression of the computation.  <a href="#abc5d65959a7499510d81a0bafe9a078d">More...</a><br /></td></tr>
<tr class="separator:abc5d65959a7499510d81a0bafe9a078d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cca4650b13a542a52b12a300e35bc92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a1cca4650b13a542a52b12a300e35bc92">set_inline</a> (bool is_inline=true)</td></tr>
<tr class="memdesc:a1cca4650b13a542a52b12a300e35bc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the computation is inline or not, based on the value of <code>is_inline</code>.  <a href="#a1cca4650b13a542a52b12a300e35bc92">More...</a><br /></td></tr>
<tr class="separator:a1cca4650b13a542a52b12a300e35bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0ccbb692cb39e21370f0f715d0c3b"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a91d0ccbb692cb39e21370f0f715d0c3b">is_inline_computation</a> () const </td></tr>
<tr class="memdesc:a91d0ccbb692cb39e21370f0f715d0c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the computation is inline.  <a href="#a91d0ccbb692cb39e21370f0f715d0c3b">More...</a><br /></td></tr>
<tr class="separator:a91d0ccbb692cb39e21370f0f715d0c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0c7011fba7e94bb836e7e5f1a55261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8e0c7011fba7e94bb836e7e5f1a55261">shift</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, int n)</td></tr>
<tr class="memdesc:a8e0c7011fba7e94bb836e7e5f1a55261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the loop level <code>L0</code> of the iteration space by <code>n</code> iterations.  <a href="#a8e0c7011fba7e94bb836e7e5f1a55261">More...</a><br /></td></tr>
<tr class="separator:a8e0c7011fba7e94bb836e7e5f1a55261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792cc56bccec244b942a862800c5589a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a792cc56bccec244b942a862800c5589a">skew</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> i, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> j, int f, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> ni, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> nj)</td></tr>
<tr class="memdesc:a792cc56bccec244b942a862800c5589a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply loop skewing on the loop levels <code>i</code> and <code>j</code> with a skewing factor of <code>f</code>.  <a href="#a792cc56bccec244b942a862800c5589a">More...</a><br /></td></tr>
<tr class="separator:a792cc56bccec244b942a862800c5589a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80eb1e0a9516089270495fa1f93effda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a80eb1e0a9516089270495fa1f93effda">skew</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> i, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> j, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> k, int factor, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> ni, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> nj, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> nk)</td></tr>
<tr class="memdesc:a80eb1e0a9516089270495fa1f93effda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply loop skewing on the loop levels <code>i</code>, <code>j</code> and <code>k</code> with a skewing factor of <code>f</code>.  <a href="#a80eb1e0a9516089270495fa1f93effda">More...</a><br /></td></tr>
<tr class="separator:a80eb1e0a9516089270495fa1f93effda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b457bc242dc982b9ece456a5e5a8e87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a3b457bc242dc982b9ece456a5e5a8e87">skew</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> i, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> j, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> k, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> l, int factor, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> ni, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> nj, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> nk, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> nl)</td></tr>
<tr class="memdesc:a3b457bc242dc982b9ece456a5e5a8e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply loop skewing on the loop levels <code>i</code>, <code>j</code>, <code>k</code>, <code>l</code> with a skewing factor of <code>f</code>.  <a href="#a3b457bc242dc982b9ece456a5e5a8e87">More...</a><br /></td></tr>
<tr class="separator:a3b457bc242dc982b9ece456a5e5a8e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac302dac11da3329af21685d91227201f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac302dac11da3329af21685d91227201f">skew</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> i, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> j, int factor)</td></tr>
<tr class="memdesc:ac302dac11da3329af21685d91227201f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac302dac11da3329af21685d91227201f">More...</a><br /></td></tr>
<tr class="separator:ac302dac11da3329af21685d91227201f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc304a57aa1bd62f1087f48ccfa909a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#adc304a57aa1bd62f1087f48ccfa909a7">skew</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> i, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> j, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> k, int factor)</td></tr>
<tr class="memdesc:adc304a57aa1bd62f1087f48ccfa909a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#adc304a57aa1bd62f1087f48ccfa909a7">More...</a><br /></td></tr>
<tr class="separator:adc304a57aa1bd62f1087f48ccfa909a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d9b0deb8554546e7b9f68fe33a2747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a97d9b0deb8554546e7b9f68fe33a2747">skew</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> i, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> j, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> k, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> l, int factor)</td></tr>
<tr class="memdesc:a97d9b0deb8554546e7b9f68fe33a2747"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a97d9b0deb8554546e7b9f68fe33a2747">More...</a><br /></td></tr>
<tr class="separator:a97d9b0deb8554546e7b9f68fe33a2747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f8c339f68c5cd8aaf55a483e15b831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a17f8c339f68c5cd8aaf55a483e15b831">skew</a> (int i, int j, int factor)</td></tr>
<tr class="memdesc:a17f8c339f68c5cd8aaf55a483e15b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a17f8c339f68c5cd8aaf55a483e15b831">More...</a><br /></td></tr>
<tr class="separator:a17f8c339f68c5cd8aaf55a483e15b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7656f0747b1a0aaaa8a68e501a5063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a3e7656f0747b1a0aaaa8a68e501a5063">skew</a> (int i, int j, int k, int factor)</td></tr>
<tr class="memdesc:a3e7656f0747b1a0aaaa8a68e501a5063"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a3e7656f0747b1a0aaaa8a68e501a5063">More...</a><br /></td></tr>
<tr class="separator:a3e7656f0747b1a0aaaa8a68e501a5063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1c710c53696989fcd150c4c7aa2d2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ade1c710c53696989fcd150c4c7aa2d2f">skew</a> (int i, int j, int k, int l, int factor)</td></tr>
<tr class="memdesc:ade1c710c53696989fcd150c4c7aa2d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ade1c710c53696989fcd150c4c7aa2d2f">More...</a><br /></td></tr>
<tr class="separator:ade1c710c53696989fcd150c4c7aa2d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f5c3c9ca7a9dad31d53936cd268ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab7f5c3c9ca7a9dad31d53936cd268ee9">split</a> (int L0, int sizeX)</td></tr>
<tr class="memdesc:ab7f5c3c9ca7a9dad31d53936cd268ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to void <a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4" title="Split the loop level L0 of the iteration space into two new loop levels. ">split(tiramisu::var L0, int sizeX)</a>;.  <a href="#ab7f5c3c9ca7a9dad31d53936cd268ee9">More...</a><br /></td></tr>
<tr class="separator:ab7f5c3c9ca7a9dad31d53936cd268ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718678aa2f3dfddc06fbd6760db9c12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a718678aa2f3dfddc06fbd6760db9c12f">storage_fold</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> dim, int f)</td></tr>
<tr class="memdesc:a718678aa2f3dfddc06fbd6760db9c12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold the storage of the computation.  <a href="#a718678aa2f3dfddc06fbd6760db9c12f">More...</a><br /></td></tr>
<tr class="separator:a718678aa2f3dfddc06fbd6760db9c12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab741d4c5e5dfd5bc0f079fdd681196da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab741d4c5e5dfd5bc0f079fdd681196da">store_at</a> (<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0)</td></tr>
<tr class="memdesc:ab741d4c5e5dfd5bc0f079fdd681196da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the storage of this computation in the loop level <code>L0</code>.  <a href="#ab741d4c5e5dfd5bc0f079fdd681196da">More...</a><br /></td></tr>
<tr class="separator:ab741d4c5e5dfd5bc0f079fdd681196da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ba81bf0611bb2f058ae7659fefd561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a37ba81bf0611bb2f058ae7659fefd561">tag_parallel_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:a37ba81bf0611bb2f058ae7659fefd561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be parallelized.  <a href="#a37ba81bf0611bb2f058ae7659fefd561">More...</a><br /></td></tr>
<tr class="separator:a37ba81bf0611bb2f058ae7659fefd561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1791e78809423426079f5063dfb8229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aa1791e78809423426079f5063dfb8229">tag_parallel_level</a> (int L)</td></tr>
<tr class="memdesc:aa1791e78809423426079f5063dfb8229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to void <a class="el" href="classtiramisu_1_1computation.html#aa1791e78809423426079f5063dfb8229" title="Identical to void tag_parallel_level(int L);. ">tag_parallel_level(int L)</a>;.  <a href="#aa1791e78809423426079f5063dfb8229">More...</a><br /></td></tr>
<tr class="separator:aa1791e78809423426079f5063dfb8229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1c88a897e6ebd7c6e9b7bf0a35c963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963">tag_vector_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int len)</td></tr>
<tr class="memdesc:a6b1c88a897e6ebd7c6e9b7bf0a35c963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be vectorized.  <a href="#a6b1c88a897e6ebd7c6e9b7bf0a35c963">More...</a><br /></td></tr>
<tr class="separator:a6b1c88a897e6ebd7c6e9b7bf0a35c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e11c118fc21f59a2bc60be2b932baba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a1e11c118fc21f59a2bc60be2b932baba">tag_vector_level</a> (int L, int len)</td></tr>
<tr class="memdesc:a1e11c118fc21f59a2bc60be2b932baba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to void <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level(tiramisu::var L, int len)</a>;.  <a href="#a1e11c118fc21f59a2bc60be2b932baba">More...</a><br /></td></tr>
<tr class="separator:a1e11c118fc21f59a2bc60be2b932baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7d0d28bfc5cef46d45483bc1c6385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385">tag_unroll_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:a2ab7d0d28bfc5cef46d45483bc1c6385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be unrolled.  <a href="#a2ab7d0d28bfc5cef46d45483bc1c6385">More...</a><br /></td></tr>
<tr class="separator:a2ab7d0d28bfc5cef46d45483bc1c6385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c8deb246b1df5e86da2b8cd0402ff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a72c8deb246b1df5e86da2b8cd0402ff1">tag_unroll_level</a> (int L)</td></tr>
<tr class="memdesc:a72c8deb246b1df5e86da2b8cd0402ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to void <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level(tiramisu::var L)</a>;.  <a href="#a72c8deb246b1df5e86da2b8cd0402ff1">More...</a><br /></td></tr>
<tr class="separator:a72c8deb246b1df5e86da2b8cd0402ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d25e2d293ad234774e33529c514d08"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad8d25e2d293ad234774e33529c514d08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ad8d25e2d293ad234774e33529c514d08">operator()</a> (Args...args)</td></tr>
<tr class="memdesc:ad8d25e2d293ad234774e33529c514d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator: C0(i,j) represents an access to the element (i,j) of the computation C0.  <a href="#ad8d25e2d293ad234774e33529c514d08">More...</a><br /></td></tr>
<tr class="separator:ad8d25e2d293ad234774e33529c514d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a62f6300ec610784687428bf87a1974"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a3a62f6300ec610784687428bf87a1974">operator expr</a> ()</td></tr>
<tr class="separator:a3a62f6300ec610784687428bf87a1974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0fb17a4eaa9cf0fa5d13833d7700a5d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a0fb17a4eaa9cf0fa5d13833d7700a5d6">after_low_level</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;comp, int level)</td></tr>
<tr class="memdesc:a0fb17a4eaa9cf0fa5d13833d7700a5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run after the computation <code>comp</code>.  <a href="#a0fb17a4eaa9cf0fa5d13833d7700a5d6">More...</a><br /></td></tr>
<tr class="separator:a0fb17a4eaa9cf0fa5d13833d7700a5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d4acb53e46a781989f5500195905a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a475d4acb53e46a781989f5500195905a">after_low_level</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;comp, std::vector&lt; int &gt; levels)</td></tr>
<tr class="memdesc:a475d4acb53e46a781989f5500195905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run after the computation <code>comp</code>.  <a href="#a475d4acb53e46a781989f5500195905a">More...</a><br /></td></tr>
<tr class="separator:a475d4acb53e46a781989f5500195905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab20ae0ad5898c983c07f8fdf7539d754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab20ae0ad5898c983c07f8fdf7539d754">before</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;consumer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:ab20ae0ad5898c983c07f8fdf7539d754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run before the computation <code>consumer</code> at the loop level <code>L</code>.  <a href="#ab20ae0ad5898c983c07f8fdf7539d754">More...</a><br /></td></tr>
<tr class="separator:ab20ae0ad5898c983c07f8fdf7539d754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a284f6a8c4a388d15ffa3b40bbfaf5693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693">store_in</a> (<a class="el" href="classtiramisu_1_1buffer.html">buffer</a> *buff)</td></tr>
<tr class="memdesc:a284f6a8c4a388d15ffa3b40bbfaf5693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store this computation in <code>buff</code>.  <a href="#a284f6a8c4a388d15ffa3b40bbfaf5693">More...</a><br /></td></tr>
<tr class="separator:a284f6a8c4a388d15ffa3b40bbfaf5693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c9d8987709a5b9f19746585dba6a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac9c9d8987709a5b9f19746585dba6a3d">store_in</a> (<a class="el" href="classtiramisu_1_1buffer.html">buffer</a> *buff, std::vector&lt; <a class="el" href="classtiramisu_1_1expr.html">expr</a> &gt; iterators)</td></tr>
<tr class="memdesc:ac9c9d8987709a5b9f19746585dba6a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store this computation in <code>buff</code>.  <a href="#ac9c9d8987709a5b9f19746585dba6a3d">More...</a><br /></td></tr>
<tr class="separator:ac9c9d8987709a5b9f19746585dba6a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b2f3533b7bc2cdfd7adeb524fa6aa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0">compute_at</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;consumer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:ac2b2f3533b7bc2cdfd7adeb524fa6aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assumes that <code>consumer</code> consumes values produced by this computation (which is the producer).  <a href="#ac2b2f3533b7bc2cdfd7adeb524fa6aa0">More...</a><br /></td></tr>
<tr class="separator:ac2b2f3533b7bc2cdfd7adeb524fa6aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e20ef79cfe01a33adf299a9bfb1f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aa4e20ef79cfe01a33adf299a9bfb1f93">compute_at</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;consumer, int L)</td></tr>
<tr class="memdesc:aa4e20ef79cfe01a33adf299a9bfb1f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store this computation in <code>buff</code>.  <a href="#aa4e20ef79cfe01a33adf299a9bfb1f93">More...</a><br /></td></tr>
<tr class="separator:aa4e20ef79cfe01a33adf299a9bfb1f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6392098da556121e4374966a4f1dc58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab6392098da556121e4374966a4f1dc58">compute_maximal_AST_depth</a> ()</td></tr>
<tr class="memdesc:ab6392098da556121e4374966a4f1dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the time-space domain and construct an AST that scans that time-space domain, then compute the depth of this AST.  <a href="#ab6392098da556121e4374966a4f1dc58">More...</a><br /></td></tr>
<tr class="separator:ab6392098da556121e4374966a4f1dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d593256de8e2cb409af0f06280afdc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7d593256de8e2cb409af0f06280afdc2">dump_iteration_domain</a> () const </td></tr>
<tr class="memdesc:a7d593256de8e2cb409af0f06280afdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the iteration domain of the computation.  <a href="#a7d593256de8e2cb409af0f06280afdc2">More...</a><br /></td></tr>
<tr class="separator:a7d593256de8e2cb409af0f06280afdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1923f57930c0c415bc5706df6622e2e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a1923f57930c0c415bc5706df6622e2e0">dump_schedule</a> () const </td></tr>
<tr class="memdesc:a1923f57930c0c415bc5706df6622e2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the schedule of the computation.  <a href="#a1923f57930c0c415bc5706df6622e2e0">More...</a><br /></td></tr>
<tr class="separator:a1923f57930c0c415bc5706df6622e2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa762a4850f735ec990442a610943c574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aa762a4850f735ec990442a610943c574">dump</a> () const </td></tr>
<tr class="memdesc:aa762a4850f735ec990442a610943c574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the computation on stdout.  <a href="#aa762a4850f735ec990442a610943c574">More...</a><br /></td></tr>
<tr class="separator:aa762a4850f735ec990442a610943c574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42518d8d745906145cd7128d66245eab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a42518d8d745906145cd7128d66245eab">fuse_after</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> lev, <a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;comp)</td></tr>
<tr class="memdesc:a42518d8d745906145cd7128d66245eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse this computation with the computation passed as argument in the same loop.  <a href="#a42518d8d745906145cd7128d66245eab">More...</a><br /></td></tr>
<tr class="separator:a42518d8d745906145cd7128d66245eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6459ca96b07ed425c01f7414e8b802ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6459ca96b07ed425c01f7414e8b802ee">gen_time_space_domain</a> ()</td></tr>
<tr class="memdesc:a6459ca96b07ed425c01f7414e8b802ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the time-space domain of the computation.  <a href="#a6459ca96b07ed425c01f7414e8b802ee">More...</a><br /></td></tr>
<tr class="separator:a6459ca96b07ed425c01f7414e8b802ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6438299a19e19de0601be69ac527e316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6438299a19e19de0601be69ac527e316">drop_rank_iter</a> (<a class="el" href="classtiramisu_1_1var.html">var</a> level)</td></tr>
<tr class="memdesc:a6438299a19e19de0601be69ac527e316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that the rank loop iterator should be removed from linearization.  <a href="#a6438299a19e19de0601be69ac527e316">More...</a><br /></td></tr>
<tr class="separator:a6438299a19e19de0601be69ac527e316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200631a0ebcc565558b3b0d059b503b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a4200631a0ebcc565558b3b0d059b503b">get_data_type</a> () const </td></tr>
<tr class="memdesc:a4200631a0ebcc565558b3b0d059b503b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type of the computation.  <a href="#a4200631a0ebcc565558b3b0d059b503b">More...</a><br /></td></tr>
<tr class="separator:a4200631a0ebcc565558b3b0d059b503b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391478684780e45084b4194f0fa9227d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a391478684780e45084b4194f0fa9227d">get_expr</a> () const </td></tr>
<tr class="memdesc:a391478684780e45084b4194f0fa9227d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Tiramisu expression associated with the computation.  <a href="#a391478684780e45084b4194f0fa9227d">More...</a><br /></td></tr>
<tr class="separator:a391478684780e45084b4194f0fa9227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7af0a83784d785aab31aba7490a2e"><td class="memItemLeft" align="right" valign="top">isl_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6bb7af0a83784d785aab31aba7490a2e">get_iteration_domain</a> () const </td></tr>
<tr class="memdesc:a6bb7af0a83784d785aab31aba7490a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the iteration domain of the computation.  <a href="#a6bb7af0a83784d785aab31aba7490a2e">More...</a><br /></td></tr>
<tr class="separator:a6bb7af0a83784d785aab31aba7490a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2d40251b2e238ca21e0bb75f1a0bb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8f2d40251b2e238ca21e0bb75f1a0bb9">get_last_update</a> ()</td></tr>
<tr class="memdesc:a8f2d40251b2e238ca21e0bb75f1a0bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last update of a computation.  <a href="#a8f2d40251b2e238ca21e0bb75f1a0bb9">More...</a><br /></td></tr>
<tr class="separator:a8f2d40251b2e238ca21e0bb75f1a0bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae158ced2b6599209fcc50cd2ab82a6b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ae158ced2b6599209fcc50cd2ab82a6b0">get_loop_level_number_from_dimension_name</a> (std::string dim_name)</td></tr>
<tr class="memdesc:ae158ced2b6599209fcc50cd2ab82a6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the time-space domain (the range of the schedule) and return the loop level number that correspond to the dimension named <code>dim</code>.  <a href="#ae158ced2b6599209fcc50cd2ab82a6b0">More...</a><br /></td></tr>
<tr class="separator:ae158ced2b6599209fcc50cd2ab82a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433130664f3849602e012178a59f9ef6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a433130664f3849602e012178a59f9ef6">get_name</a> () const </td></tr>
<tr class="memdesc:a433130664f3849602e012178a59f9ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the computation.  <a href="#a433130664f3849602e012178a59f9ef6">More...</a><br /></td></tr>
<tr class="separator:a433130664f3849602e012178a59f9ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedbe74d3ed8336ac3f6e031877b5208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">computation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aeedbe74d3ed8336ac3f6e031877b5208">get_predecessor</a> ()</td></tr>
<tr class="memdesc:aeedbe74d3ed8336ac3f6e031877b5208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the computation scheduled immediately before this computation, or a null pointer if none exist.  <a href="#aeedbe74d3ed8336ac3f6e031877b5208">More...</a><br /></td></tr>
<tr class="separator:aeedbe74d3ed8336ac3f6e031877b5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164265c5ca09e16c173a332beec66db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a164265c5ca09e16c173a332beec66db6">get_update</a> (int index)</td></tr>
<tr class="memdesc:a164265c5ca09e16c173a332beec66db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>index</code> update that has been added to this computation such that:  <a href="#a164265c5ca09e16c173a332beec66db6">More...</a><br /></td></tr>
<tr class="separator:a164265c5ca09e16c173a332beec66db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf61fd7919949c0cbdd4787c4115cdf"><td class="memItemLeft" align="right" valign="top">isl_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#accf61fd7919949c0cbdd4787c4115cdf">get_schedule</a> () const </td></tr>
<tr class="memdesc:accf61fd7919949c0cbdd4787c4115cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the schedule of the computation.  <a href="#accf61fd7919949c0cbdd4787c4115cdf">More...</a><br /></td></tr>
<tr class="separator:accf61fd7919949c0cbdd4787c4115cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5a1055aba6dd921819da184e9862b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a9ab5a1055aba6dd921819da184e9862b">gpu_tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, int sizeX, int sizeY)</td></tr>
<tr class="memdesc:a9ab5a1055aba6dd921819da184e9862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the computation and then tag the outermost tile dimension to be mapped to GPU blocks and tag the innermost tile dimensions to be mapped to GPU threads.  <a href="#a9ab5a1055aba6dd921819da184e9862b">More...</a><br /></td></tr>
<tr class="separator:a9ab5a1055aba6dd921819da184e9862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472f916f4550eaa3e04e4736dfbaa7f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a472f916f4550eaa3e04e4736dfbaa7f1">gpu_tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, int sizeX, int sizeY, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_inner)</td></tr>
<tr class="memdesc:a472f916f4550eaa3e04e4736dfbaa7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store this computation in <code>buff</code>.  <a href="#a472f916f4550eaa3e04e4736dfbaa7f1">More...</a><br /></td></tr>
<tr class="separator:a472f916f4550eaa3e04e4736dfbaa7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf69c837e5565afb53a1f241e1f3c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aaaf69c837e5565afb53a1f241e1f3c97">gpu_tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, int sizeX, int sizeY, int sizeZ)</td></tr>
<tr class="memdesc:aaaf69c837e5565afb53a1f241e1f3c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store this computation in <code>buff</code>.  <a href="#aaaf69c837e5565afb53a1f241e1f3c97">More...</a><br /></td></tr>
<tr class="separator:aaaf69c837e5565afb53a1f241e1f3c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec0e40b795bb05c002b9410386d95ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a1ec0e40b795bb05c002b9410386d95ff">gpu_tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, int sizeX, int sizeY, int sizeZ, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2_inner)</td></tr>
<tr class="memdesc:a1ec0e40b795bb05c002b9410386d95ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store this computation in <code>buff</code>.  <a href="#a1ec0e40b795bb05c002b9410386d95ff">More...</a><br /></td></tr>
<tr class="separator:a1ec0e40b795bb05c002b9410386d95ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7f412d1ba941c990f18225d43f0fb621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7f412d1ba941c990f18225d43f0fb621">set_access</a> (std::string access_str)</td></tr>
<tr class="memdesc:a7f412d1ba941c990f18225d43f0fb621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the access relation of the computation.  <a href="#a7f412d1ba941c990f18225d43f0fb621">More...</a><br /></td></tr>
<tr class="separator:a7f412d1ba941c990f18225d43f0fb621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981e28763928d5faa066f9350b9547dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a981e28763928d5faa066f9350b9547dc">set_access</a> (isl_map *access)</td></tr>
<tr class="memdesc:a981e28763928d5faa066f9350b9547dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the access relation of the computation.  <a href="#a981e28763928d5faa066f9350b9547dc">More...</a><br /></td></tr>
<tr class="separator:a981e28763928d5faa066f9350b9547dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a73950403fb75df11351e34baa830c8e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a73950403fb75df11351e34baa830c8e4">set_low_level_schedule</a> (isl_map *map)</td></tr>
<tr class="memdesc:a73950403fb75df11351e34baa830c8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the schedule indicated by <code>map</code>.  <a href="#a73950403fb75df11351e34baa830c8e4">More...</a><br /></td></tr>
<tr class="separator:a73950403fb75df11351e34baa830c8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cb781f866beb35776a60b7e8c095dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a65cb781f866beb35776a60b7e8c095dc">set_low_level_schedule</a> (std::string map_str)</td></tr>
<tr class="memdesc:a65cb781f866beb35776a60b7e8c095dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the schedule indicated by <code>map</code>.  <a href="#a65cb781f866beb35776a60b7e8c095dc">More...</a><br /></td></tr>
<tr class="separator:a65cb781f866beb35776a60b7e8c095dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a71ba41faf9403d2db864c886db0301d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4">split</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, int sizeX)</td></tr>
<tr class="memdesc:a71ba41faf9403d2db864c886db0301d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the loop level <code>L0</code> of the iteration space into two new loop levels.  <a href="#a71ba41faf9403d2db864c886db0301d4">More...</a><br /></td></tr>
<tr class="separator:a71ba41faf9403d2db864c886db0301d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6781ec005a7e9696b77f06d29d0d8e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6781ec005a7e9696b77f06d29d0d8e14">split</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, int sizeX, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner)</td></tr>
<tr class="memdesc:a6781ec005a7e9696b77f06d29d0d8e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the loop level <code>L0</code> of the iteration space into two new loop levels.  <a href="#a6781ec005a7e9696b77f06d29d0d8e14">More...</a><br /></td></tr>
<tr class="separator:a6781ec005a7e9696b77f06d29d0d8e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a12cf0a03413b4be996c62c1ea61f5d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a12cf0a03413b4be996c62c1ea61f5d8d">tag_gpu_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1)</td></tr>
<tr class="memdesc:a12cf0a03413b4be996c62c1ea61f5d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU.  <a href="#a12cf0a03413b4be996c62c1ea61f5d8d">More...</a><br /></td></tr>
<tr class="separator:a12cf0a03413b4be996c62c1ea61f5d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fb03cd144ca7282b5fbcf3a5aeb32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ae4fb03cd144ca7282b5fbcf3a5aeb32e">tag_gpu_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L3)</td></tr>
<tr class="memdesc:ae4fb03cd144ca7282b5fbcf3a5aeb32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU.  <a href="#ae4fb03cd144ca7282b5fbcf3a5aeb32e">More...</a><br /></td></tr>
<tr class="separator:ae4fb03cd144ca7282b5fbcf3a5aeb32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21a3469f5925d109b1f850ea9a9dd57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab21a3469f5925d109b1f850ea9a9dd57">tag_gpu_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L3, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L4, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L5)</td></tr>
<tr class="memdesc:ab21a3469f5925d109b1f850ea9a9dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU.  <a href="#ab21a3469f5925d109b1f850ea9a9dd57">More...</a><br /></td></tr>
<tr class="separator:ab21a3469f5925d109b1f850ea9a9dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8de3bf0e99741287af84f3af8a4c5365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8de3bf0e99741287af84f3af8a4c5365">tag_distribute_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:a8de3bf0e99741287af84f3af8a4c5365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be distributed.  <a href="#a8de3bf0e99741287af84f3af8a4c5365">More...</a><br /></td></tr>
<tr class="separator:a8de3bf0e99741287af84f3af8a4c5365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38935a2b30a261024a24e6257f6a25b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a38935a2b30a261024a24e6257f6a25b2">tag_distribute_level</a> (int L)</td></tr>
<tr class="memdesc:a38935a2b30a261024a24e6257f6a25b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be distributed.  <a href="#a38935a2b30a261024a24e6257f6a25b2">More...</a><br /></td></tr>
<tr class="separator:a38935a2b30a261024a24e6257f6a25b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5fd9fb1ba61cae4576a39f189b46b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aa5fd9fb1ba61cae4576a39f189b46b5f">then</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;next_computation, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:aa5fd9fb1ba61cae4576a39f189b46b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run before the computation <code>next_computation</code> at the loop level <code>L</code> and return <code>next_computation</code>.  <a href="#aa5fd9fb1ba61cae4576a39f189b46b5f">More...</a><br /></td></tr>
<tr class="separator:aa5fd9fb1ba61cae4576a39f189b46b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0fc402b23a4d138cd21eda8e041a8a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a0fc402b23a4d138cd21eda8e041a8a03">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, int sizeX, int sizeY)</td></tr>
<tr class="memdesc:a0fc402b23a4d138cd21eda8e041a8a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#a0fc402b23a4d138cd21eda8e041a8a03">More...</a><br /></td></tr>
<tr class="separator:a0fc402b23a4d138cd21eda8e041a8a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a63c66e3db24bd85b1ffe7b23822c6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a5a63c66e3db24bd85b1ffe7b23822c6c">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, int sizeX, int sizeY, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_inner)</td></tr>
<tr class="memdesc:a5a63c66e3db24bd85b1ffe7b23822c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#a5a63c66e3db24bd85b1ffe7b23822c6c">More...</a><br /></td></tr>
<tr class="separator:a5a63c66e3db24bd85b1ffe7b23822c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bc997ad3dacfd4bea812c068b87ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ae37bc997ad3dacfd4bea812c068b87ff">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, int sizeX, int sizeY, int sizeZ)</td></tr>
<tr class="memdesc:ae37bc997ad3dacfd4bea812c068b87ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#ae37bc997ad3dacfd4bea812c068b87ff">More...</a><br /></td></tr>
<tr class="separator:ae37bc997ad3dacfd4bea812c068b87ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b17318417cb0d0419f66bf8fb742246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8b17318417cb0d0419f66bf8fb742246">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, int sizeX, int sizeY, int sizeZ, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2_inner)</td></tr>
<tr class="memdesc:a8b17318417cb0d0419f66bf8fb742246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#a8b17318417cb0d0419f66bf8fb742246">More...</a><br /></td></tr>
<tr class="separator:a8b17318417cb0d0419f66bf8fb742246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adf6cd1724b02fa9bfc79dd903ec8af57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#adf6cd1724b02fa9bfc79dd903ec8af57">tile</a> (int L0, int L1, int sizeX, int sizeY)</td></tr>
<tr class="memdesc:adf6cd1724b02fa9bfc79dd903ec8af57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#adf6cd1724b02fa9bfc79dd903ec8af57">More...</a><br /></td></tr>
<tr class="separator:adf6cd1724b02fa9bfc79dd903ec8af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453a8ec8ce2cfba365da5d5b1f659cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a453a8ec8ce2cfba365da5d5b1f659cbe">tile</a> (int L0, int L1, int L2, int sizeX, int sizeY, int sizeZ)</td></tr>
<tr class="memdesc:a453a8ec8ce2cfba365da5d5b1f659cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#a453a8ec8ce2cfba365da5d5b1f659cbe">More...</a><br /></td></tr>
<tr class="separator:a453a8ec8ce2cfba365da5d5b1f659cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a68cc2dc757dfb181548b739c901ed6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a68cc2dc757dfb181548b739c901ed6f9">unroll</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int fac)</td></tr>
<tr class="memdesc:a68cc2dc757dfb181548b739c901ed6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>.  <a href="#a68cc2dc757dfb181548b739c901ed6f9">More...</a><br /></td></tr>
<tr class="separator:a68cc2dc757dfb181548b739c901ed6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566d1284eef9d999112660a3fff30561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a566d1284eef9d999112660a3fff30561">unroll</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int fac, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_inner)</td></tr>
<tr class="memdesc:a566d1284eef9d999112660a3fff30561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>.  <a href="#a566d1284eef9d999112660a3fff30561">More...</a><br /></td></tr>
<tr class="separator:a566d1284eef9d999112660a3fff30561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abfb52d2e77fd1157343350a01fe905ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab">vectorize</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int v)</td></tr>
<tr class="memdesc:abfb52d2e77fd1157343350a01fe905ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize the loop level <code>L</code>.  <a href="#abfb52d2e77fd1157343350a01fe905ab">More...</a><br /></td></tr>
<tr class="separator:abfb52d2e77fd1157343350a01fe905ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f4dd685fd931af56ba633fef4b184b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac7f4dd685fd931af56ba633fef4b184b">vectorize</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int v, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_inner)</td></tr>
<tr class="memdesc:ac7f4dd685fd931af56ba633fef4b184b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize the loop level <code>L</code>.  <a href="#ac7f4dd685fd931af56ba633fef4b184b">More...</a><br /></td></tr>
<tr class="separator:ac7f4dd685fd931af56ba633fef4b184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac7b8cc73ce1d6c04b4fa241bd6490478"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtiramisu_1_1xfer.html">xfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac7b8cc73ce1d6c04b4fa241bd6490478">create_xfer</a> (std::string send_iter_domain, std::string recv_iter_domain, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> send_dest, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> recv_src, <a class="el" href="classtiramisu_1_1xfer__prop.html">xfer_prop</a> send_prop, <a class="el" href="classtiramisu_1_1xfer__prop.html">xfer_prop</a> recv_prop, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> send_expr, <a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *fct)</td></tr>
<tr class="separator:ac7b8cc73ce1d6c04b4fa241bd6490478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39927e93c8473e4402e9317e4426c492"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtiramisu_1_1xfer.html">xfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a39927e93c8473e4402e9317e4426c492">create_xfer</a> (std::string iter_domain, <a class="el" href="classtiramisu_1_1xfer__prop.html">xfer_prop</a> prop, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> <a class="el" href="classtiramisu_1_1expr.html">expr</a>, <a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *fct)</td></tr>
<tr class="separator:a39927e93c8473e4402e9317e4426c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7b874384f567f7bbf60bbf58f86e6ddc"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classtiramisu_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc">root</a></td></tr>
<tr class="memdesc:a7b874384f567f7bbf60bbf58f86e6ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">root_dimension is a number used to specify the dimension level known as root.  <a href="#a7b874384f567f7bbf60bbf58f86e6ddc">More...</a><br /></td></tr>
<tr class="separator:a7b874384f567f7bbf60bbf58f86e6ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e56982ea734feb3dc1670969ff617d"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab8e56982ea734feb3dc1670969ff617d">root_dimension</a> = -1</td></tr>
<tr class="memdesc:ab8e56982ea734feb3dc1670969ff617d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> but to be used with scheduling functions that take loop level (integers) as input instead of <a class="el" href="classtiramisu_1_1var.html" title="A class that represents constant variable references. ">tiramisu::var</a>.  <a href="#ab8e56982ea734feb3dc1670969ff617d">More...</a><br /></td></tr>
<tr class="separator:ab8e56982ea734feb3dc1670969ff617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac7bd79205a3bf5cc46d8560be5ded585"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac7bd79205a3bf5cc46d8560be5ded585">computation</a> ()</td></tr>
<tr class="memdesc:ac7bd79205a3bf5cc46d8560be5ded585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy constructor for derived classes.  <a href="#ac7bd79205a3bf5cc46d8560be5ded585">More...</a><br /></td></tr>
<tr class="separator:ac7bd79205a3bf5cc46d8560be5ded585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcc3aba7d0c5d6775a275a441c079ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a1fcc3aba7d0c5d6775a275a441c079ce">compute_buffer_size</a> ()</td></tr>
<tr class="memdesc:a1fcc3aba7d0c5d6775a275a441c079ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the buffer allocated automatically to hold the results of this computation.  <a href="#a1fcc3aba7d0c5d6775a275a441c079ce">More...</a><br /></td></tr>
<tr class="separator:a1fcc3aba7d0c5d6775a275a441c079ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709f142d8fe21f84c4e2862b6258ffc8"><td class="memItemLeft" align="right" valign="top">isl_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a709f142d8fe21f84c4e2862b6258ffc8">get_ctx</a> () const </td></tr>
<tr class="memdesc:a709f142d8fe21f84c4e2862b6258ffc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context of the computations.  <a href="#a709f142d8fe21f84c4e2862b6258ffc8">More...</a><br /></td></tr>
<tr class="separator:a709f142d8fe21f84c4e2862b6258ffc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d38b03bc8941b5b602d29ef784b8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a87d38b03bc8941b5b602d29ef784b8d5">get_predicate</a> ()</td></tr>
<tr class="memdesc:a87d38b03bc8941b5b602d29ef784b8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the predicate around this computation if a predicate was added using <a class="el" href="classtiramisu_1_1computation.html#aadcd659e4fabb0cce1562e4c1fe326e7" title="Add a predicate (condition) on the computation. ">add_predicate()</a>.  <a href="#a87d38b03bc8941b5b602d29ef784b8d5">More...</a><br /></td></tr>
<tr class="separator:a87d38b03bc8941b5b602d29ef784b8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e02c13f2209c23f1be123610832da0"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a55e02c13f2209c23f1be123610832da0">get_unique_name</a> () const </td></tr>
<tr class="memdesc:a55e02c13f2209c23f1be123610832da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique name of computation; made of the following pattern: [computation name]@[computation address in memory].  <a href="#a55e02c13f2209c23f1be123610832da0">More...</a><br /></td></tr>
<tr class="separator:a55e02c13f2209c23f1be123610832da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d43ec6acc2227685fd8a67348fa502"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a32d43ec6acc2227685fd8a67348fa502">has_multiple_definitions</a> ()</td></tr>
<tr class="memdesc:a32d43ec6acc2227685fd8a67348fa502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation has multiple definitions.  <a href="#a32d43ec6acc2227685fd8a67348fa502">More...</a><br /></td></tr>
<tr class="separator:a32d43ec6acc2227685fd8a67348fa502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603834cd99c57d0d8c72dc594951f45f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a603834cd99c57d0d8c72dc594951f45f">init_computation</a> (std::string iteration_space_str, <a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *fct, const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &amp;e, bool schedule_this_computation, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a> t)</td></tr>
<tr class="memdesc:a603834cd99c57d0d8c72dc594951f45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a computation.  <a href="#a603834cd99c57d0d8c72dc594951f45f">More...</a><br /></td></tr>
<tr class="separator:a603834cd99c57d0d8c72dc594951f45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a8505ff00dffa95433ddf76b4e402d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a10a8505ff00dffa95433ddf76b4e402d">set_name</a> (const std::string &amp;n)</td></tr>
<tr class="memdesc:a10a8505ff00dffa95433ddf76b4e402d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the computation.  <a href="#a10a8505ff00dffa95433ddf76b4e402d">More...</a><br /></td></tr>
<tr class="separator:a10a8505ff00dffa95433ddf76b4e402d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf462a6d70885f440e1438fad18de0c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#adf462a6d70885f440e1438fad18de0c5">full_loop_level_collapse</a> (int level, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> collapse_from_iter)</td></tr>
<tr class="memdesc:adf462a6d70885f440e1438fad18de0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse all the iterations of a loop into one single iteration.  <a href="#adf462a6d70885f440e1438fad18de0c5">More...</a><br /></td></tr>
<tr class="separator:adf462a6d70885f440e1438fad18de0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6840a9cdd8ef455dd2fb943cbbeb0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aea6840a9cdd8ef455dd2fb943cbbeb0f">computation</a> (std::string name, std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt; iterator_variables, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e, bool schedule_this_computation, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">primitive_t</a> t)</td></tr>
<tr class="memdesc:aea6840a9cdd8ef455dd2fb943cbbeb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#aea6840a9cdd8ef455dd2fb943cbbeb0f">More...</a><br /></td></tr>
<tr class="separator:aea6840a9cdd8ef455dd2fb943cbbeb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acf43f20d096f8919e93f73facba6c9e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#acf43f20d096f8919e93f73facba6c9e6">set_schedule</a> (isl_map *map)</td></tr>
<tr class="memdesc:acf43f20d096f8919e93f73facba6c9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the schedule indicated by <code>map</code>.  <a href="#acf43f20d096f8919e93f73facba6c9e6">More...</a><br /></td></tr>
<tr class="separator:acf43f20d096f8919e93f73facba6c9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e50d6910128b7dff0c82ae09ecf9e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aa5e50d6910128b7dff0c82ae09ecf9e5">set_schedule</a> (std::string map_str)</td></tr>
<tr class="memdesc:aa5e50d6910128b7dff0c82ae09ecf9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the schedule indicated by <code>map</code>.  <a href="#aa5e50d6910128b7dff0c82ae09ecf9e5">More...</a><br /></td></tr>
<tr class="separator:aa5e50d6910128b7dff0c82ae09ecf9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8aae053de52966a72d5faee3a75662c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8aae053de52966a72d5faee3a75662c0">_is_library_call</a></td></tr>
<tr class="memdesc:a8aae053de52966a72d5faee3a75662c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this computation represents a library call.  <a href="#a8aae053de52966a72d5faee3a75662c0">More...</a><br /></td></tr>
<tr class="separator:a8aae053de52966a72d5faee3a75662c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c98b7f222724166710f4718592d90c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a40c98b7f222724166710f4718592d90c">library_call_name</a></td></tr>
<tr class="memdesc:a40c98b7f222724166710f4718592d90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the computation represents a library call, this is the name of the function.  <a href="#a40c98b7f222724166710f4718592d90c">More...</a><br /></td></tr>
<tr class="separator:a40c98b7f222724166710f4718592d90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1db85e39c0d9db0d4edf4209164dfc"><td class="memItemLeft" align="right" valign="top">isl_ast_expr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7d1db85e39c0d9db0d4edf4209164dfc">wait_index_expr</a></td></tr>
<tr class="memdesc:a7d1db85e39c0d9db0d4edf4209164dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index expression just for the request buffer.  <a href="#a7d1db85e39c0d9db0d4edf4209164dfc">More...</a><br /></td></tr>
<tr class="separator:a7d1db85e39c0d9db0d4edf4209164dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that represents computations. </p>
<p>A computation is an expression associated with an iteration domain. A computation indicates what needs to be computed (the expression that should be computed). A computation has three representations:</p><ul>
<li>Level I: this level specifies "what" should be computed but does not specify "when" (order) and "where" (on which processor) each expression should be computed. This level also does not specify where computations should be stored in memory and in which data layout.</li>
<li>Level II: this level specifies "what" should be computed, "when", i.e. the order in which the computation should be executed with regard to the other computations. And "where" each computation should be computed (i.e., on which processor). This level still does not specify where computations should be stored in memory and their data layout.</li>
<li>Level III: this level is similar to Level 2 but it specifies where computations should be stored in memory and the data layout. </li>
</ul>

<p>Definition at line <a class="el" href="core_8h_source.html#l01320">1320</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac7bd79205a3bf5cc46d8560be5ded585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy constructor for derived classes. </p>

</div>
</div>
<a class="anchor" id="aea6840a9cdd8ef455dd2fb943cbbeb0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a802535b5fb6144e54a83051f7b612b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iteration_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *&#160;</td>
          <td class="paramname"><em>fct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for computations. </p>
<p><code>iteration_domain</code> is a string that represents the iteration domain of the computation. The iteration domain should be written in the ISL format (<a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> Section 1.2.1).</p>
<p>The iteration domain of a statement is a set that contains all of the execution instances of the statement (a statement in a loop has an execution instance for each loop iteration in which it executes). Each execution instance of a statement in a loop nest is uniquely represented by an identifier and a tuple of integers (typically, the values of the outer loop iterators).</p>
<p>For example, the iteration space of the statement S0 in the following loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;2; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;3; j++)</div><div class="line">     S0;</div></div><!-- fragment --><p>is {S0[0,0], S0[0,1], S0[0,2], S0[1,0], S0[1,1], S0[1,2]}</p>
<p>S0[0,0] is the execution instance of S0 in the iteration [0,0].</p>
<p>The previous set of integer tuples can be compactly described by affine constraints as follows</p>
<p>{S0[i,j]: 0&lt;=i&lt;2 and 0&lt;=j&lt;3}</p>
<p>In general, the loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;M; j++)</div><div class="line">     S0;</div></div><!-- fragment --><p>has the following iteration domain</p>
<p>{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;M}</p>
<p>This should be read as: the set of points [i,j] such that 0&lt;=i&lt;N and 0&lt;=j&lt;M.</p>
<p>The name of the computation in the iteration domain should not start with _ (an underscore). Names starting with _ are reserved names.</p>
<p><code>e</code> is the expression computed by the computation. It is possible to declare the computation without specifying the expression. The expression can be specified later using <a class="el" href="classtiramisu_1_1computation.html#abc5d65959a7499510d81a0bafe9a078d" title="Set the expression of the computation. ">computation::set_expression()</a>. An example of setting the expression after declaring the computation is presented in tests/test_04.cpp.</p>
<p><code>schedule_this_computation</code> should be set to true if the computation is supposed to be schedule and code is supposed to be generated from the computation. Set it to false if you just want to use the computation to represent a buffer (that is passed as an argument to the function) and you do not intend to generate code for the computation. An example where this argument is set to false is presented in tests/test_14.cpp.</p>
<p><code>t</code> is the type of the computation, i.e. the type of the expression computed by the computation. Example of types include (p_uint8, p_uint16, p_uint32, ...).</p>
<p><code>fct</code> is a pointer to the Tiramisu function where this computation should be added.</p>
<p>Bound Inference: The user can declare computations without providing any constraint about the iteration domain, in this case he can rely on bound inference to infer the constraints about each iteration domain. The user needs only to provide constraints over the domains of the last computations (last consumers), and Tiramisu will propagate these constraints to all the chain of computations that precede those consumers. Note that bound inference is not possible if you have multiple definitions of the same computation. In such a case, you should provide constraints over the iteration domain when you declare the computation.</p>
<p>Examples about bound inference are provided in test_22 to test_25. </p>

</div>
</div>
<a class="anchor" id="a2ccc96c6683e8c57bd53844ac7470996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for computations. </p>
<p>Same as <a class="el" href="classtiramisu_1_1computation.html#ae1e7897febc0bdabef7af09b8f236cdf">tiramisu::computation::computation(std::string name, std::vector&lt;var&gt; iterator_variables, tiramisu::expr e)</a> except that is has the following additional argument:</p>
<p><code>schedule_this_computation</code> indicates whether this computation should to be scheduled. </p>

</div>
</div>
<a class="anchor" id="abf47e619e720940f071e78a425e621e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae1e7897febc0bdabef7af09b8f236cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for computations. </p>
<p>Declare a computation. A computation in Tiramisu is the equivalent of a a statement surrounded by a loop nest in C (an example is provided later).</p>
<p><code>name</code> is the name of the computation.</p>
<p><code>iterator_variables</code> is a vector that represents the loop iterators around the computation.</p>
<p><code>e</code> is the expression computed by the computation.</p>
<p>For example, if we have two iterator variables</p>
<div class="fragment"><div class="line">var i(<span class="stringliteral">&quot;i&quot;</span>, 0, 20), j(<span class="stringliteral">&quot;j&quot;</span>, 0, 30);</div></div><!-- fragment --><p>and we have the following computation declaration</p>
<div class="fragment"><div class="line"><a class="code" href="classtiramisu_1_1computation.html#ac7bd79205a3bf5cc46d8560be5ded585">computation</a> S(<span class="stringliteral">&quot;S&quot;</span>, {i,j}, 4);</div></div><!-- fragment --><p>This is equivalent to writing the following C code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;20; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;30; j++)</div><div class="line">     S(i,j) = 4;</div></div><!-- fragment --><p>More precisely, the vector {i, j} specifies the iteration domain of the computation S0. In this case, 0&lt;=i&lt;20 and 0&lt;=j&lt;30.</p>
<p>It is possible to declare the computation without specifying the expression. The expression can be specified later using <a class="el" href="classtiramisu_1_1computation.html#abc5d65959a7499510d81a0bafe9a078d" title="Set the expression of the computation. ">computation::set_expression()</a>. An example of setting the expression after declaring the computation is presented in tutorial 04. Usually this is needed for writing reductions. </p>

</div>
</div>
<a class="anchor" id="ad4285634473bd55d0f9158e87babd8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aeda461fdf0185f176ef6ae4957b3d536"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<code>t</code> is the type of the computation, i.e. </p>
<p>the type of the expression computed by the computation. Example of types include (p_uint8, p_uint16, p_uint32, ...).</p>
<p>Usually, this constructor is used to declare buffer wrappers.</p>
<p>For example, if we have two iterator variables</p>
<div class="fragment"><div class="line">var i(<span class="stringliteral">&quot;i&quot;</span>, 0, 20), j(<span class="stringliteral">&quot;j&quot;</span>, 0, 30);</div></div><!-- fragment --><p>and we have the following computation declaration</p>
<div class="fragment"><div class="line"><a class="code" href="classtiramisu_1_1computation.html#ac7bd79205a3bf5cc46d8560be5ded585">computation</a> S(<span class="stringliteral">&quot;S&quot;</span>, {i,j}, <a class="code" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354a30ef1bc35093eebdf14ea07eb4131c78">p_uint8</a>);</div></div><!-- fragment --><p>This can be used a wrapper on a buffer buf[20, 30] where the buffer elements are of type uint8. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l02676">2676</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

<p>References <a class="el" href="expr_8h_source.html#l00219">tiramisu::expr::dtype</a>.</p>

</div>
</div>
<a class="anchor" id="a66c3eef364ae4d60ab836ebffcfed12c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1var.html">var</a> &gt;&#160;</td>
          <td class="paramname"><em>iterator_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l02686">2686</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00137">tiramisu::a_temporary</a>, and <a class="el" href="expr_8h_source.html#l00219">tiramisu::expr::dtype</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac731631b840bb6853af793ecc8b96253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::add_associated_let_stmt </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>access_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a let statement that is associated to this computation. </p>
<p>The let statement will be executed before the computation (more precisely, between this computation and any computation that preceeds it). The variable defined by the let statement can be accessible by this computation alone. i.e., it cannot be used in any other computation. </p>

</div>
</div>
<a class="anchor" id="a3bbac0c76308eea25b37462028bff3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tiramisu::computation::add_definitions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iteration_domain_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *&#160;</td>
          <td class="paramname"><em>fct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add definitions of computations that have the same name as this computation. </p>
<p>The arguments of this function are identical to the arguments of the computation constructor. In general, this function is used to express reductions and to express computation updates.</p>
<p>In other words, this function should be used if the user has already declared a set of computations C and wants to declare more computations that have the same name.</p>
<p>Example: Let's assume we want to declare the following two computations.</p>
<div class="fragment"><div class="line"><span class="comment">// First computation</span></div><div class="line">{C[i]: 0&lt;=i&lt;10}: 0</div><div class="line"></div><div class="line"><span class="comment">// Second computation</span></div><div class="line">{C[i]: 10&lt;=i&lt;20}: 1</div></div><!-- fragment --><p>To do this this, we can declare the first computation using the computation constructor and declare the second computation using <a class="el" href="classtiramisu_1_1computation.html#a3bbac0c76308eea25b37462028bff3c4" title="Add definitions of computations that have the same name as this computation. ">add_definitions()</a>.</p>
<p>The use of add_computation is purely due to restrictions imposed by the C++ language and not by the Tiramisu framework itself. This is mainly because in C++, it is not possible to declare two objects with the same name, for example one cannot do</p>
<p>computation C(...); computation C(...);</p>
<p>In order to declare the second set of computations, we chose to use the add_definitions function to avoid this problem.</p>
<p>The newly added computations must have the same name and the same access function as the initial set of computations but can have a different expression.</p>
<p>An example of using this function is available in test_26. </p>

<p>Reimplemented in <a class="el" href="classtiramisu_1_1wait.html#a1d3920be5f7b708b29c9dd78b3f4f8c7">tiramisu::wait</a>, <a class="el" href="classtiramisu_1_1recv.html#a8a2661c43f388090fbb6f78f336f6f95">tiramisu::recv</a>, and <a class="el" href="classtiramisu_1_1send.html#a0337af888f54201bcd9028ad6b828398">tiramisu::send</a>.</p>

</div>
</div>
<a class="anchor" id="aadcd659e4fabb0cce1562e4c1fe326e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::add_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a predicate (condition) on the computation. </p>
<p>The computation will be executed only if this condition is true.</p>
<p>The predicate can be an affine or a non-affine expression. If you need to put a condition around a block of statements (i.e., a sequence of computations), then you can perform that by adding a predicate to each one of those computations. The compiler will then transform automatically the multiple conditions (condition around each computation) into one condition around the whole block. </p>

</div>
</div>
<a class="anchor" id="a27181748bece6f76f528982089951e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run after the computation <code>comp</code>. </p>
<p>This computation is placed after <code>comp</code> in the loop level <code>level</code>. <code>level</code> is a loop level in this computation.</p>
<p>The root level is <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a>. The global variable <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> is equivalent to var("root").</p>
<p>For example assuming we have the two computations </p><pre class="fragment">{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {S1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}
</pre><p>In order to make S1 run after S0 in the i loop, one should use </p><pre class="fragment">S1.after(S0, i)
</pre><p>which means: S1 is after S0 at the loop level i (which is loop level 0).</p>
<p>The corresponding code is</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S0;</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S1;</div><div class="line">}</div></div><!-- fragment --><p>S1.after(S0, j)</p>
<p>means: S1 is after S0 at the loop level j (which is 1) and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    S0;</div><div class="line">    S1;</div><div class="line">  }</div></div><!-- fragment --><p>S1.after(S0, computation::root) means S1 is after S0 at the main program level and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S0;</div><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S1;</div></div><!-- fragment --><p>Note that as with all other scheduling methods:</p><ul>
<li>Calling this method with the same computations overwrites the level if it is higher.</li>
<li>A computation being scheduled after another computation at level L means it is scheduled after that computation at all levels lower than L.</li>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a class="anchor" id="af8a37d6620871e18fb1df0a5a3bbb936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is equivalent to void <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">after(computation &amp;comp, tiramisu::var iterator)</a>; except that it uses loop level numbers (0, 1, 2, ...) instead of using loop variables (<a class="el" href="classtiramisu_1_1var.html" title="A class that represents constant variable references. ">tiramisu::var</a>). </p>
<p>Tiramisu internally represent loop levels using numbers instead of variable names, and this is the actual function used internally.</p>
<p>The outermost loop level is 0. The root level is <a class="el" href="classtiramisu_1_1computation.html#ab8e56982ea734feb3dc1670969ff617d" title="Equivalent of computation::root but to be used with scheduling functions that take loop level (intege...">computation::root_dimension</a>.</p>
<p>For example assuming we have the two computations </p><pre class="fragment">{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {S1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}
</pre><p>In order to make S1 run after S0 in the i loop, one should use </p><pre class="fragment">S1.after(S0,0)
</pre><p>which means: S1 is after S0 at the loop level 0 (which is i).</p>
<p>The corresponding code is</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S0;</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S1;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0fb17a4eaa9cf0fa5d13833d7700a5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::after_low_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run after the computation <code>comp</code>. </p>
<p>The computations are placed after each other in the loop level <code>level</code>. The outermost loop level is 0. The root level is <a class="el" href="classtiramisu_1_1computation.html#ab8e56982ea734feb3dc1670969ff617d" title="Equivalent of computation::root but to be used with scheduling functions that take loop level (intege...">computation::root_dimension</a>.</p>
<p>For example assuming we have the two computations </p><pre class="fragment">{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {S1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}
</pre><p>In order to make S1 run after S0 in the i loop, one should use </p><pre class="fragment">S1.after_low_level(S0,0)
</pre><p>which means: S1 is after S0 at the loop level 0 (which is i).</p>
<p>The corresponding code is</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S0;</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S1;</div><div class="line">}</div></div><!-- fragment --><p>S1.after_low_level(S0,1)</p>
<p>means: S1 is after S0 at the loop level 1 (which is j) and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    S0;</div><div class="line">    S1;</div><div class="line">  }</div></div><!-- fragment --><p>S1.after_low_level(S0, computation::root_dimension) means S1 is after S0 at the main program level and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S0;</div><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S1;</div></div><!-- fragment --><p>To specify that this computation is after <code>comp</code> in multiple levels, the user can provide those levels in the <code>levels</code> vector.</p>
<p>S1.after_low_level(S0, {0,1})</p>
<p>means that S1 is after S0 in the loop level 0 and in the loop level 1.</p>
<p>Note that</p>
<p>S1.after_low_level(S0, L)</p>
<p>would mean that S1 and S0 share the same loop nests for all the loop levels that are before L and that S1 is after S0 in L only. S1 is not after S0 in the loop levels that are before L. </p>

</div>
</div>
<a class="anchor" id="a475d4acb53e46a781989f5500195905a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::after_low_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run after the computation <code>comp</code>. </p>
<p>The computations are placed after each other in the loop level <code>level</code>. The outermost loop level is 0. The root level is <a class="el" href="classtiramisu_1_1computation.html#ab8e56982ea734feb3dc1670969ff617d" title="Equivalent of computation::root but to be used with scheduling functions that take loop level (intege...">computation::root_dimension</a>.</p>
<p>For example assuming we have the two computations </p><pre class="fragment">{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {S1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}
</pre><p>In order to make S1 run after S0 in the i loop, one should use </p><pre class="fragment">S1.after_low_level(S0,0)
</pre><p>which means: S1 is after S0 at the loop level 0 (which is i).</p>
<p>The corresponding code is</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S0;</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S1;</div><div class="line">}</div></div><!-- fragment --><p>S1.after_low_level(S0,1)</p>
<p>means: S1 is after S0 at the loop level 1 (which is j) and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    S0;</div><div class="line">    S1;</div><div class="line">  }</div></div><!-- fragment --><p>S1.after_low_level(S0, computation::root_dimension) means S1 is after S0 at the main program level and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S0;</div><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S1;</div></div><!-- fragment --><p>To specify that this computation is after <code>comp</code> in multiple levels, the user can provide those levels in the <code>levels</code> vector.</p>
<p>S1.after_low_level(S0, {0,1})</p>
<p>means that S1 is after S0 in the loop level 0 and in the loop level 1.</p>
<p>Note that</p>
<p>S1.after_low_level(S0, L)</p>
<p>would mean that S1 and S0 share the same loop nests for all the loop levels that are before L and that S1 is after S0 in L only. S1 is not after S0 in the loop levels that are before L. </p>

</div>
</div>
<a class="anchor" id="aeff7cfc17026f57393b1c315a686f5cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::allocate_and_map_buffer_automatically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aed">tiramisu::argument_t</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aeda241ff08aa2bef135ac9f6691651244f5">tiramisu::a_temporary</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a58c50e1fde5b2ebc3e27575d10448769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::apply_transformation_on_schedule </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>map_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a transformation on the schedule. </p>
<p>This transformation is from the time-space domain to the time-space domain. It is applied on the range of the schedule (i.e., on the output of the schedule relation).</p>
<p>For example, to shift the i dimension of the time-processor domain of C0, you can apply the transformation</p>
<p>C0[0, 0, i, 0, j, 0] -&gt; C0[0, 0, i+2, 0, j, 0]</p>
<p>To apply an interchange, you would do</p>
<p>C0[0, 0, i, 0, j, 0] -&gt; C0[0, 0, j, 0, i, 0] </p>

</div>
</div>
<a class="anchor" id="ab20ae0ad5898c983c07f8fdf7539d754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run before the computation <code>consumer</code> at the loop level <code>L</code>. </p>
<p>Notes</p><ul>
<li>The loop level <code>L</code> is a loop level of this computation.</li>
<li>Use <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> to indicate the root dimension (i.e. the outermost time-space dimension).</li>
<li>Calling this method with the same computations overwrites the level if it is higher.</li>
<li>A computation being scheduled after another computation at level L means it is scheduled after that computation at all levels lower than L.</li>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a class="anchor" id="acc052433e6e1eb850e1df1f128986b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>before_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>before_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>after_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>after_l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run after <code>before_comp</code> at the loop level <code>before_l</code>, and before <code>after_comp</code> at loop level <code>after_l</code>. </p>
<p>The outermost loop level is 0.</p>
<p>Use <a class="el" href="classtiramisu_1_1computation.html#ab8e56982ea734feb3dc1670969ff617d" title="Equivalent of computation::root but to be used with scheduling functions that take loop level (intege...">computation::root_dimension</a> to indicate the root dimension (i.e. the outermost time-space dimension).</p>
<p>If there was already a direct scheduling between <code>before_comp</code> and <code>after_comp</code> (e.g. using before, after, between...), that schedule is overwritten; i.e. it no longer exists/has an effect.</p>
<p>Note that as with all other scheduling methods:</p><ul>
<li>Calling this method with the same computations overwrites the levels if they are higher.</li>
<li>A computation being scheduled after another computation at level L means it is scheduled after that computation at all levels lower than L.</li>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac2b2f3533b7bc2cdfd7adeb524fa6aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::compute_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assumes that <code>consumer</code> consumes values produced by this computation (which is the producer). </p>
<p>Compute this computation as needed for each unique value of the <code>consumer</code>.</p>
<p>This computation is scheduled so that the values consumed by the <code>consumer</code> are computed at the level <code>L</code> and in the same loop nest of the consumer. <code>L</code> is a loop level in the consumer.</p>
<p>If the consumer needs this computation to be computed redundantly, the function creates the necessary redundant computations and schedules them before the consumer.</p>
<p>This function performs the following:</p><ul>
<li>schedules this computation to be executed as needed before the consumer.</li>
<li>if this computation needs to be computed redundantly, redundant computations are create.</li>
</ul>
<p>This function does not:</p><ul>
<li>create any data mapping to this computation. It is up to the user to provide an access relation to this computation as he would do to any other normal computation.</li>
<li>it does not allocate any buffer to this computation. It is up to the user to declare a buffer where the results of this computation will be stored.</li>
</ul>
<p>If this functions creates a duplicate of the computation, the user does not need to set its access relation. The duplicated computation will automatically have the same access relation as the original computation. This access relation is set automatically.</p>
<p>This function does not return a handler to manipulate the duplicate computation. It does not allow the user to manipulate the duplicate freely. The duplicate is scheduled automatically to be executed before the consumer. </p>

</div>
</div>
<a class="anchor" id="aa4e20ef79cfe01a33adf299a9bfb1f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::compute_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store this computation in <code>buff</code>. </p>
<p>Let us assume that we have a computation C:</p>
<div class="fragment"><div class="line">{C[i]: 0&lt;=i&lt;N}</div></div><!-- fragment --><p>and that we want to store each C(i) in bufC[i]. Then we can use <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> to indicate that as follows:</p>
<div class="fragment"><div class="line">C.store_in(&amp;bufC)</div></div><!-- fragment --><p>This mans that each computation C(i) will be stored in the buffer location bufC[i].</p>
<p>If <code>iterators</code> is specified, the <code>iterators</code> are used to specify how the computation is mapped to the buffer. If the dimensions of this computation are in0, in1, ..., inn and if <code>iterators</code> are equal to im0, im1, ..., imm then the computation is mapped as follows</p>
<div class="fragment"><div class="line">C[in0, in1, ..., inn]-&gt;bufC[im0, im1, ..., imm].</div></div><!-- fragment --><p>i.e., the computation C[in0, in1, ..., inn] is stored in bufC[im0, im1, ..., imm].</p>
<p>This can be used to store the data in many ways (reordering the storage, storing into modulo buffers, ...).</p>
<p>Assuming we have have computation D(i,j) that has the following iteration domain:</p>
<div class="fragment"><div class="line">{D[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and assuming we have a buffer bufD.</p>
<p>The <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> function can be used to implement many types of data mappings:</p><ul>
<li>Store the computation D to a scalar: D.store_in(&amp;bufD, {}). This mans that D(i) will be stored in bufD[0] (which represents a scalar).</li>
<li>Store a 2 dimensional computation into a 1-dimensional buffer: D.store_in(&amp;bufD, {i});</li>
<li>Change the order of storage. D.store_in(&amp;bufD, {j, i}) will store D(i,j) in bufD(j,i).</li>
<li>Store the computation in a circular buffer (modulo storage). D.store_in(&amp;bufD, {i%4, j%4}); This will store D(i,j) in bufD[i%4, j%4]. Assuming the buffer bufD is a 4x4 buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1fcc3aba7d0c5d6775a275a441c079ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&gt;* tiramisu::computation::compute_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of the buffer allocated automatically to hold the results of this computation. </p>

</div>
</div>
<a class="anchor" id="ab6392098da556121e4374966a4f1dc58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiramisu::computation::compute_maximal_AST_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the time-space domain and construct an AST that scans that time-space domain, then compute the depth of this AST. </p>
<p>This is useful for example to know if all the dimensions of the time-space domain will correspond to a loop level in the final generated AST. </p>

</div>
</div>
<a class="anchor" id="ac7b8cc73ce1d6c04b4fa241bd6490478"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtiramisu_1_1xfer.html">xfer</a> tiramisu::computation::create_xfer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>send_iter_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>recv_iter_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>send_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>recv_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1xfer__prop.html">xfer_prop</a>&#160;</td>
          <td class="paramname"><em>send_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1xfer__prop.html">xfer_prop</a>&#160;</td>
          <td class="paramname"><em>recv_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>send_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *&#160;</td>
          <td class="paramname"><em>fct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a39927e93c8473e4402e9317e4426c492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtiramisu_1_1xfer.html">xfer</a> tiramisu::computation::create_xfer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iter_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1xfer__prop.html">xfer_prop</a>&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *&#160;</td>
          <td class="paramname"><em>fct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6438299a19e19de0601be69ac527e316"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::drop_rank_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify that the rank loop iterator should be removed from linearization. </p>

</div>
</div>
<a class="anchor" id="aa762a4850f735ec990442a610943c574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the computation on stdout. </p>
<p>This is mainly useful for debugging. </p>

</div>
</div>
<a class="anchor" id="a7d593256de8e2cb409af0f06280afdc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::dump_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the iteration domain of the computation. </p>
<p>This is useful for debugging. </p>

</div>
</div>
<a class="anchor" id="a1923f57930c0c415bc5706df6622e2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::dump_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the schedule of the computation. </p>
<p>This is mainly useful for debugging.</p>
<p>The schedule is a relation between the iteration space and the time space. The relation provides a logical date of execution for each point in the iteration space. The schedule needs first to be set before calling this function. </p>

</div>
</div>
<a class="anchor" id="adf462a6d70885f440e1438fad18de0c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::full_loop_level_collapse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>collapse_from_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collapse all the iterations of a loop into one single iteration. </p>

</div>
</div>
<a class="anchor" id="a42518d8d745906145cd7128d66245eab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::fuse_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse this computation with the computation passed as argument in the same loop. </p>
<p>Run this computation after that computation. Fuse them at the loop level <code>lev</code>.</p>
<p>For example, assuming we have the following computations</p>
<p>{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}, {S1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {S2[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}.</p>
<p>Without fusion, these computations would be equivalent to the following loops nests</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S1;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S2;</div></div><!-- fragment --><p>To fuse them, one should call</p>
<div class="fragment"><div class="line">S2.fuse_after(j, S1);</div><div class="line">S1.fuse_after(j, S0);</div></div><!-- fragment --><p>This would result in fusing S2 with S0 and S1 at loop level j. S2 will be scheduled for execution after S0 and S1. The resulting code would look like</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    S0;</div><div class="line">    S1;</div><div class="line">    S2;</div><div class="line">  }</div></div><!-- fragment --><p>Calling</p>
<div class="fragment"><div class="line">S2.fuse_after(i, S1);</div><div class="line">S1.fuse_after(i, S0);</div></div><!-- fragment --><p>would result in the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S0;</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S1;</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S2;</div><div class="line">}</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="core_8h_source.html#l03230">3230</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

<p>References <a class="el" href="expr_8h_source.html#l00702">tiramisu::expr::get_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a6459ca96b07ed425c01f7414e8b802ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gen_time_space_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the time-space domain of the computation. </p>
<p>In this representation, the logical time of execution and the processor where the computation will be executed are both specified. The memory location where computations will be stored in memory is not specified at the level. </p>

</div>
</div>
<a class="anchor" id="afc26ee002088f750f872e6747f9582cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a>* tiramisu::computation::get_automatically_allocated_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer that was allocated automatically using high level data mapping functions. </p>
<p>If no automatic buffer was allocated, this function returns NULL. </p>

</div>
</div>
<a class="anchor" id="a709f142d8fe21f84c4e2862b6258ffc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_ctx* tiramisu::computation::get_ctx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the context of the computations. </p>

</div>
</div>
<a class="anchor" id="a4200631a0ebcc565558b3b0d059b503b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a> tiramisu::computation::get_data_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data type of the computation. </p>

</div>
</div>
<a class="anchor" id="a391478684780e45084b4194f0fa9227d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&amp; tiramisu::computation::get_expr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Tiramisu expression associated with the computation. </p>

</div>
</div>
<a class="anchor" id="a6bb7af0a83784d785aab31aba7490a2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isl_set* tiramisu::computation::get_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the iteration domain of the computation. </p>
<p>In this representation, the order of execution of computations is not specified, the computations are also not mapped to memory. </p>

</div>
</div>
<a class="anchor" id="a8f2d40251b2e238ca21e0bb75f1a0bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a>&amp; tiramisu::computation::get_last_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last update of a computation. </p>

</div>
</div>
<a class="anchor" id="ae158ced2b6599209fcc50cd2ab82a6b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tiramisu::computation::get_loop_level_number_from_dimension_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dim_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search the time-space domain (the range of the schedule) and return the loop level number that correspond to the dimension named <code>dim</code>. </p>
<p>In other words, translate the vector of dimension name (<code>dim_name</code>) into a loop level number. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l03281">3281</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="a433130664f3849602e012178a59f9ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; tiramisu::computation::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the computation. </p>

</div>
</div>
<a class="anchor" id="aeedbe74d3ed8336ac3f6e031877b5208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">computation</a>* tiramisu::computation::get_predecessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the computation scheduled immediately before this computation, or a null pointer if none exist. </p>

</div>
</div>
<a class="anchor" id="a87d38b03bc8941b5b602d29ef784b8d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> tiramisu::computation::get_predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the predicate around this computation if a predicate was added using <a class="el" href="classtiramisu_1_1computation.html#aadcd659e4fabb0cce1562e4c1fe326e7" title="Add a predicate (condition) on the computation. ">add_predicate()</a>. </p>

</div>
</div>
<a class="anchor" id="accf61fd7919949c0cbdd4787c4115cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isl_map* tiramisu::computation::get_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the schedule of the computation. </p>

</div>
</div>
<a class="anchor" id="a55e02c13f2209c23f1be123610832da0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string tiramisu::computation::get_unique_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unique name of computation; made of the following pattern: [computation name]@[computation address in memory]. </p>

</div>
</div>
<a class="anchor" id="a164265c5ca09e16c173a332beec66db6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a>&amp; tiramisu::computation::get_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>index</code> update that has been added to this computation such that: </p>
<ul>
<li>If <code>index</code> == 0, then this computation is returned.</li>
<li>If <code>&gt;</code> 0, then it returns the pth computation added through add_definitions. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9ab5a1055aba6dd921819da184e9862b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gpu_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the computation and then tag the outermost tile dimension to be mapped to GPU blocks and tag the innermost tile dimensions to be mapped to GPU threads. </p>
<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. <code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels (i.e., <code>L0</code> = <code>L1</code> + 1) and they should satisfy <code>L0</code> &gt; <code>L1</code>.</p>
<p><code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a class="anchor" id="a472f916f4550eaa3e04e4736dfbaa7f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gpu_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store this computation in <code>buff</code>. </p>
<p>Let us assume that we have a computation C:</p>
<div class="fragment"><div class="line">{C[i]: 0&lt;=i&lt;N}</div></div><!-- fragment --><p>and that we want to store each C(i) in bufC[i]. Then we can use <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> to indicate that as follows:</p>
<div class="fragment"><div class="line">C.store_in(&amp;bufC)</div></div><!-- fragment --><p>This mans that each computation C(i) will be stored in the buffer location bufC[i].</p>
<p>If <code>iterators</code> is specified, the <code>iterators</code> are used to specify how the computation is mapped to the buffer. If the dimensions of this computation are in0, in1, ..., inn and if <code>iterators</code> are equal to im0, im1, ..., imm then the computation is mapped as follows</p>
<div class="fragment"><div class="line">C[in0, in1, ..., inn]-&gt;bufC[im0, im1, ..., imm].</div></div><!-- fragment --><p>i.e., the computation C[in0, in1, ..., inn] is stored in bufC[im0, im1, ..., imm].</p>
<p>This can be used to store the data in many ways (reordering the storage, storing into modulo buffers, ...).</p>
<p>Assuming we have have computation D(i,j) that has the following iteration domain:</p>
<div class="fragment"><div class="line">{D[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and assuming we have a buffer bufD.</p>
<p>The <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> function can be used to implement many types of data mappings:</p><ul>
<li>Store the computation D to a scalar: D.store_in(&amp;bufD, {}). This mans that D(i) will be stored in bufD[0] (which represents a scalar).</li>
<li>Store a 2 dimensional computation into a 1-dimensional buffer: D.store_in(&amp;bufD, {i});</li>
<li>Change the order of storage. D.store_in(&amp;bufD, {j, i}) will store D(i,j) in bufD(j,i).</li>
<li>Store the computation in a circular buffer (modulo storage). D.store_in(&amp;bufD, {i%4, j%4}); This will store D(i,j) in bufD[i%4, j%4]. Assuming the buffer bufD is a 4x4 buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="aaaf69c837e5565afb53a1f241e1f3c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gpu_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store this computation in <code>buff</code>. </p>
<p>Let us assume that we have a computation C:</p>
<div class="fragment"><div class="line">{C[i]: 0&lt;=i&lt;N}</div></div><!-- fragment --><p>and that we want to store each C(i) in bufC[i]. Then we can use <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> to indicate that as follows:</p>
<div class="fragment"><div class="line">C.store_in(&amp;bufC)</div></div><!-- fragment --><p>This mans that each computation C(i) will be stored in the buffer location bufC[i].</p>
<p>If <code>iterators</code> is specified, the <code>iterators</code> are used to specify how the computation is mapped to the buffer. If the dimensions of this computation are in0, in1, ..., inn and if <code>iterators</code> are equal to im0, im1, ..., imm then the computation is mapped as follows</p>
<div class="fragment"><div class="line">C[in0, in1, ..., inn]-&gt;bufC[im0, im1, ..., imm].</div></div><!-- fragment --><p>i.e., the computation C[in0, in1, ..., inn] is stored in bufC[im0, im1, ..., imm].</p>
<p>This can be used to store the data in many ways (reordering the storage, storing into modulo buffers, ...).</p>
<p>Assuming we have have computation D(i,j) that has the following iteration domain:</p>
<div class="fragment"><div class="line">{D[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and assuming we have a buffer bufD.</p>
<p>The <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> function can be used to implement many types of data mappings:</p><ul>
<li>Store the computation D to a scalar: D.store_in(&amp;bufD, {}). This mans that D(i) will be stored in bufD[0] (which represents a scalar).</li>
<li>Store a 2 dimensional computation into a 1-dimensional buffer: D.store_in(&amp;bufD, {i});</li>
<li>Change the order of storage. D.store_in(&amp;bufD, {j, i}) will store D(i,j) in bufD(j,i).</li>
<li>Store the computation in a circular buffer (modulo storage). D.store_in(&amp;bufD, {i%4, j%4}); This will store D(i,j) in bufD[i%4, j%4]. Assuming the buffer bufD is a 4x4 buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1ec0e40b795bb05c002b9410386d95ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gpu_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store this computation in <code>buff</code>. </p>
<p>Let us assume that we have a computation C:</p>
<div class="fragment"><div class="line">{C[i]: 0&lt;=i&lt;N}</div></div><!-- fragment --><p>and that we want to store each C(i) in bufC[i]. Then we can use <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> to indicate that as follows:</p>
<div class="fragment"><div class="line">C.store_in(&amp;bufC)</div></div><!-- fragment --><p>This mans that each computation C(i) will be stored in the buffer location bufC[i].</p>
<p>If <code>iterators</code> is specified, the <code>iterators</code> are used to specify how the computation is mapped to the buffer. If the dimensions of this computation are in0, in1, ..., inn and if <code>iterators</code> are equal to im0, im1, ..., imm then the computation is mapped as follows</p>
<div class="fragment"><div class="line">C[in0, in1, ..., inn]-&gt;bufC[im0, im1, ..., imm].</div></div><!-- fragment --><p>i.e., the computation C[in0, in1, ..., inn] is stored in bufC[im0, im1, ..., imm].</p>
<p>This can be used to store the data in many ways (reordering the storage, storing into modulo buffers, ...).</p>
<p>Assuming we have have computation D(i,j) that has the following iteration domain:</p>
<div class="fragment"><div class="line">{D[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and assuming we have a buffer bufD.</p>
<p>The <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> function can be used to implement many types of data mappings:</p><ul>
<li>Store the computation D to a scalar: D.store_in(&amp;bufD, {}). This mans that D(i) will be stored in bufD[0] (which represents a scalar).</li>
<li>Store a 2 dimensional computation into a 1-dimensional buffer: D.store_in(&amp;bufD, {i});</li>
<li>Change the order of storage. D.store_in(&amp;bufD, {j, i}) will store D(i,j) in bufD(j,i).</li>
<li>Store the computation in a circular buffer (modulo storage). D.store_in(&amp;bufD, {i%4, j%4}); This will store D(i,j) in bufD[i%4, j%4]. Assuming the buffer bufD is a 4x4 buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a32d43ec6acc2227685fd8a67348fa502"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::computation::has_multiple_definitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation has multiple definitions. </p>
<p>i.e., if the computation is defined multiple times. An update is a special case where a computation is defined multiple times. Duplicate computations are another example.</p>
<p>In the following example, C is defined multiple times whereas D is defined only once.</p>
<div class="fragment"><div class="line">C(0) = 0</div><div class="line"></div><div class="line">C(i) = C(i-1) + 1</div><div class="line"></div><div class="line">D(i) = C(i) + 1</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a603834cd99c57d0d8c72dc594951f45f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::init_computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iteration_space_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *&#160;</td>
          <td class="paramname"><em>fct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a computation. </p>
<p>This is a private function that should not be called explicitly by users. </p>

</div>
</div>
<a class="anchor" id="a3370d2b63da2c87438a7d6da92afc0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::interchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchange (swap) the two loop levels <code>L0</code> and <code>L1</code>. </p>

</div>
</div>
<a class="anchor" id="a3a8a259be046d45732ef4c723470fa89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::interchange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to void <a class="el" href="classtiramisu_1_1computation.html#a3370d2b63da2c87438a7d6da92afc0e5" title="Interchange (swap) the two loop levels L0 and L1. ">interchange(tiramisu::var L0, tiramisu::var L1)</a>;. </p>

</div>
</div>
<a class="anchor" id="a91d0ccbb692cb39e21370f0f715d0c3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool tiramisu::computation::is_inline_computation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if the computation is inline. </p>

</div>
</div>
<a class="anchor" id="af8df98d2b6894124bceec12a852aca31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool tiramisu::computation::is_recv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtiramisu_1_1recv.html#a6667c1ea7a04c2144aaafb5aafd4a488">tiramisu::recv</a>.</p>

</div>
</div>
<a class="anchor" id="a253020596918f051ef183422858ea235"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool tiramisu::computation::is_send </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtiramisu_1_1send.html#a9c11609231aa38a2147e980e83ad3463">tiramisu::send</a>.</p>

</div>
</div>
<a class="anchor" id="a16655c34d71e6c5dd1e65f0b821e10ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool tiramisu::computation::is_send_recv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtiramisu_1_1send__recv.html#a196f5ded62d4c3665e35ea781ade4fdc">tiramisu::send_recv</a>.</p>

</div>
</div>
<a class="anchor" id="a1dc6962d629ebb621db5b87c546a3041"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool tiramisu::computation::is_wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtiramisu_1_1wait.html#aa976420f2d77adc9d372b61e731a4341">tiramisu::wait</a>.</p>

</div>
</div>
<a class="anchor" id="a4bb92906d4541d1ab073bf9a164bc31c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::mark_as_let_statement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark this statement as a let statement. </p>

</div>
</div>
<a class="anchor" id="af556bb9e098aaa4329981257ae45cf9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::mark_as_library_call </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark this statement as a library call. </p>

</div>
</div>
<a class="anchor" id="a3a62f6300ec610784687428bf87a1974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::operator <a class="el" href="classtiramisu_1_1expr.html">expr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8d25e2d293ad234774e33529c514d08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> tiramisu::computation::operator() </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator: C0(i,j) represents an access to the element (i,j) of the computation C0. </p>
<p>C0(i,j) represents the value computed by the computation C0(i,j) </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l04005">4005</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

<p>References <a class="el" href="expr_8h_source.html#l01021">tiramisu::expr::dump()</a>, <a class="el" href="type_8h_source.html#l00118">tiramisu::o_access</a>, and <a class="el" href="classtiramisu_1_1expr.html#a3cbc1079941cf0c7c840b238e4d53b9a">tiramisu::expr::substitute()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c748331b7a5d0c111c1bb24928ec771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::parallelize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be parallelized. </p>
<p>This function is equivalent to the function <a class="el" href="classtiramisu_1_1computation.html#a37ba81bf0611bb2f058ae7659fefd561">tiramisu::computation::tag_parallel_level()</a> . There is no difference between the two. </p>

</div>
</div>
<a class="anchor" id="a7f412d1ba941c990f18225d43f0fb621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_access </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>access_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the access relation of the computation. </p>
<p>The access relation is a relation from computations to buffer locations. <code>access_str</code> is a string that represents the relation. It is encoded in the ISL format, <a href="http://isl.gforge.inria.fr/user.html#Sets-and-Relations">http://isl.gforge.inria.fr/user.html#Sets-and-Relations</a> of relations.</p>
<p>Note that, in TIramisu, the access relations of computation that have the same name must be identical.</p>
<p>Examples: tutorial_01, tutorial_02, tutorial_08 (actually most tutorials have <a class="el" href="classtiramisu_1_1computation.html#a7f412d1ba941c990f18225d43f0fb621" title="Set the access relation of the computation. ">set_access()</a>). </p>

</div>
</div>
<a class="anchor" id="a981e28763928d5faa066f9350b9547dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_access </td>
          <td>(</td>
          <td class="paramtype">isl_map *&#160;</td>
          <td class="paramname"><em>access</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the access relation of the computation. </p>
<p>The access relation is a relation from computations to buffer locations. <code>access_str</code> is a string that represents the relation. It is encoded in the ISL format, <a href="http://isl.gforge.inria.fr/user.html#Sets-and-Relations">http://isl.gforge.inria.fr/user.html#Sets-and-Relations</a> of relations.</p>
<p>Note that, in TIramisu, the access relations of computation that have the same name must be identical.</p>
<p>Examples: tutorial_01, tutorial_02, tutorial_08 (actually most tutorials have <a class="el" href="classtiramisu_1_1computation.html#a7f412d1ba941c990f18225d43f0fb621" title="Set the access relation of the computation. ">set_access()</a>). </p>

</div>
</div>
<a class="anchor" id="abc5d65959a7499510d81a0bafe9a078d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the expression of the computation. </p>

</div>
</div>
<a class="anchor" id="a1cca4650b13a542a52b12a300e35bc92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_inline </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_inline</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the computation is inline or not, based on the value of <code>is_inline</code>. </p>
<p>If a computation is inline, accesses to the computation return the expression of that computation. E.g. if an inline computation S(i,j) is defined with the expression i + j, then S(i + 1, j * i) returns the expression i + 1 + j * i. If <code>is_inline</code> is not provided, the computation is set to be inline. </p>

</div>
</div>
<a class="anchor" id="a73950403fb75df11351e34baa830c8e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_low_level_schedule </td>
          <td>(</td>
          <td class="paramtype">isl_map *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the schedule indicated by <code>map</code>. </p>
<p><code>map</code> is a string that represents a mapping from the iteration domain to the time-space domain (the ISL format to represent maps is documented in <a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> in Sec 1.2.2).</p>
<p>The schedule is a map from the iteration domain to a time space domain. The same name of space should be used for both the range and the domain of the schedule.</p>
<p>In general, users can set the schedule using high level functions such as before(), <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">after()</a>, <a class="el" href="classtiramisu_1_1computation.html#a0fc402b23a4d138cd21eda8e041a8a03" title="Tile the two loop levels L0 and L1 with rectangular tiling. ">tile()</a>, <a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0" title="This function assumes that consumer consumes values produced by this computation (which is the produc...">compute_at()</a>, <a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a>, <a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4" title="Split the loop level L0 of the iteration space into two new loop levels. ">split()</a>, ... The use of this function is only reserved for advanced users who want a low level control of the schedule.</p>
<p>Vectors in the time-space domain have the following form</p>
<p>computation_name[redundancy_ID,static,dynamic,static,dynamic,static,dynamic,static,...]</p>
<p>The first dimension of the vector is used to indicate the redundancy ID (the notion of the redundancy ID is explained later).</p>
<p>The following dimensions are interleaved dimensions: static, dynamic, static, dynamic, ... Dynamic dimensions represent the loop levels, while static dimensions are used to order statements within a given block of statements in a given loop level. For example, the computations c0 and c1 in the following loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N: i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    c0;</div><div class="line">    c1;</div><div class="line">  }</div></div><!-- fragment --><p>have the following representations in the iteration domain</p>
<div class="fragment"><div class="line">{c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and the following representation in the time-space domain</p>
<div class="fragment"><div class="line">{c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension (dimension 0) in the time-space domain (the leftmost dimension) is the redundancy ID (in this case it is 0, the meaning of this ID will be explained later). The second dimension (starting from the left) is a static dimension, the third dimension is a dynamic dimension that represents the loop level i, ..., the fifth dimension is a dynamic dimension that represents the loop level j and the last dimension (dimension 5) is a static dimension and allows the ordering of c1 after c0 in the loop nest.</p>
<p>To transform the previous iteration domain to the time-space domain, the following schedule should be used:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]-&gt;c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension called "redundancy ID" is only meaningful if the computation is redundant. i.e., some parts of the computation are redundantly computed. Redundant computations are in general used to maximize parallelism and data locality on the expense of doing some computations redundantly. For example, if the two computations c1(i,j) and c2(i,j) both depend on the computation c0(i,j), instead of waiting for c0(i,j) to be computed and then computing c1(i,j) and c2(i,j) in parallel, the thread executing c1(i,j) can compute c0(i,j) by itself and then run c1(i,j). The thread that computes c2(i,j) can do the same and compute c0(i,j) by itself and then compute c2(i,j). In this case the two threads do not need to wait. This is done at the expense of redundant computation since c0(i,j) is computed by both threads.</p>
<p>In general redundant computations are useful when tiling stencil computations. In the context of stencils such a tiling is called "overlapped tiling". Tiles that depend on results computed by other tiles that run in parallel can compute the boundaries redundantly which allows them to avoid waiting and thus can run in parallel.</p>
<p>In Tiramisu, the user can indicate that a chunk of a computation should be computed redundantly. The original computation always has a redundancy ID equal to 0 (which means this is the original computation). The redundant chunk has an ID that is different from 0 and that is used to uniquely identify it.</p>
<p>For example if we want to compute all of c0 three times (that is, compute the original computation and compute two redundant computations), we can use the following schedules:</p>
<p>The schedule of the original computation: {c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N1: {c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N2: {c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The schedule of c0 in this case would be three maps that map c0[i,j] to the three different redundant computations in the time-processor domain:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The function <a class="el" href="classtiramisu_1_1computation.html#acf43f20d096f8919e93f73facba6c9e6" title="Set the schedule indicated by map. ">set_schedule()</a> overrides any other schedule set by the high level scheduling functions. Currently the user has to choose between using the high level scheduling functions or using this low level set_schedule function. The user cannot mix the use of the two in the same program because they are not compatible. </p>

</div>
</div>
<a class="anchor" id="a65cb781f866beb35776a60b7e8c095dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_low_level_schedule </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>map_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the schedule indicated by <code>map</code>. </p>
<p><code>map</code> is a string that represents a mapping from the iteration domain to the time-space domain (the ISL format to represent maps is documented in <a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> in Sec 1.2.2).</p>
<p>The schedule is a map from the iteration domain to a time space domain. The same name of space should be used for both the range and the domain of the schedule.</p>
<p>In general, users can set the schedule using high level functions such as before(), <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">after()</a>, <a class="el" href="classtiramisu_1_1computation.html#a0fc402b23a4d138cd21eda8e041a8a03" title="Tile the two loop levels L0 and L1 with rectangular tiling. ">tile()</a>, <a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0" title="This function assumes that consumer consumes values produced by this computation (which is the produc...">compute_at()</a>, <a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a>, <a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4" title="Split the loop level L0 of the iteration space into two new loop levels. ">split()</a>, ... The use of this function is only reserved for advanced users who want a low level control of the schedule.</p>
<p>Vectors in the time-space domain have the following form</p>
<p>computation_name[redundancy_ID,static,dynamic,static,dynamic,static,dynamic,static,...]</p>
<p>The first dimension of the vector is used to indicate the redundancy ID (the notion of the redundancy ID is explained later).</p>
<p>The following dimensions are interleaved dimensions: static, dynamic, static, dynamic, ... Dynamic dimensions represent the loop levels, while static dimensions are used to order statements within a given block of statements in a given loop level. For example, the computations c0 and c1 in the following loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N: i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    c0;</div><div class="line">    c1;</div><div class="line">  }</div></div><!-- fragment --><p>have the following representations in the iteration domain</p>
<div class="fragment"><div class="line">{c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and the following representation in the time-space domain</p>
<div class="fragment"><div class="line">{c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension (dimension 0) in the time-space domain (the leftmost dimension) is the redundancy ID (in this case it is 0, the meaning of this ID will be explained later). The second dimension (starting from the left) is a static dimension, the third dimension is a dynamic dimension that represents the loop level i, ..., the fifth dimension is a dynamic dimension that represents the loop level j and the last dimension (dimension 5) is a static dimension and allows the ordering of c1 after c0 in the loop nest.</p>
<p>To transform the previous iteration domain to the time-space domain, the following schedule should be used:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]-&gt;c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension called "redundancy ID" is only meaningful if the computation is redundant. i.e., some parts of the computation are redundantly computed. Redundant computations are in general used to maximize parallelism and data locality on the expense of doing some computations redundantly. For example, if the two computations c1(i,j) and c2(i,j) both depend on the computation c0(i,j), instead of waiting for c0(i,j) to be computed and then computing c1(i,j) and c2(i,j) in parallel, the thread executing c1(i,j) can compute c0(i,j) by itself and then run c1(i,j). The thread that computes c2(i,j) can do the same and compute c0(i,j) by itself and then compute c2(i,j). In this case the two threads do not need to wait. This is done at the expense of redundant computation since c0(i,j) is computed by both threads.</p>
<p>In general redundant computations are useful when tiling stencil computations. In the context of stencils such a tiling is called "overlapped tiling". Tiles that depend on results computed by other tiles that run in parallel can compute the boundaries redundantly which allows them to avoid waiting and thus can run in parallel.</p>
<p>In Tiramisu, the user can indicate that a chunk of a computation should be computed redundantly. The original computation always has a redundancy ID equal to 0 (which means this is the original computation). The redundant chunk has an ID that is different from 0 and that is used to uniquely identify it.</p>
<p>For example if we want to compute all of c0 three times (that is, compute the original computation and compute two redundant computations), we can use the following schedules:</p>
<p>The schedule of the original computation: {c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N1: {c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N2: {c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The schedule of c0 in this case would be three maps that map c0[i,j] to the three different redundant computations in the time-processor domain:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The function <a class="el" href="classtiramisu_1_1computation.html#acf43f20d096f8919e93f73facba6c9e6" title="Set the schedule indicated by map. ">set_schedule()</a> overrides any other schedule set by the high level scheduling functions. Currently the user has to choose between using the high level scheduling functions or using this low level set_schedule function. The user cannot mix the use of the two in the same program because they are not compatible. </p>

</div>
</div>
<a class="anchor" id="a10a8505ff00dffa95433ddf76b4e402d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the name of the computation. </p>

</div>
</div>
<a class="anchor" id="acf43f20d096f8919e93f73facba6c9e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_schedule </td>
          <td>(</td>
          <td class="paramtype">isl_map *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the schedule indicated by <code>map</code>. </p>
<p><code>map</code> is a string that represents a mapping from the iteration domain to the time-space domain (the ISL format to represent maps is documented in <a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> in Sec 1.2.2).</p>
<p>The schedule is a map from the iteration domain to a time space domain. The same name of space should be used for both the range and the domain of the schedule.</p>
<p>In general, users can set the schedule using high level functions such as before(), <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">after()</a>, <a class="el" href="classtiramisu_1_1computation.html#a0fc402b23a4d138cd21eda8e041a8a03" title="Tile the two loop levels L0 and L1 with rectangular tiling. ">tile()</a>, <a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0" title="This function assumes that consumer consumes values produced by this computation (which is the produc...">compute_at()</a>, <a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a>, <a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4" title="Split the loop level L0 of the iteration space into two new loop levels. ">split()</a>, ... The use of this function is only reserved for advanced users who want a low level control of the schedule.</p>
<p>Vectors in the time-space domain have the following form</p>
<p>computation_name[redundancy_ID,static,dynamic,static,dynamic,static,dynamic,static,...]</p>
<p>The first dimension of the vector is used to indicate the redundancy ID (the notion of the redundancy ID is explained later).</p>
<p>The following dimensions are interleaved dimensions: static, dynamic, static, dynamic, ... Dynamic dimensions represent the loop levels, while static dimensions are used to order statements within a given block of statements in a given loop level. For example, the computations c0 and c1 in the following loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N: i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    c0;</div><div class="line">    c1;</div><div class="line">  }</div></div><!-- fragment --><p>have the following representations in the iteration domain</p>
<div class="fragment"><div class="line">{c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and the following representation in the time-space domain</p>
<div class="fragment"><div class="line">{c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension (dimension 0) in the time-space domain (the leftmost dimension) is the redundancy ID (in this case it is 0, the meaning of this ID will be explained later). The second dimension (starting from the left) is a static dimension, the third dimension is a dynamic dimension that represents the loop level i, ..., the fifth dimension is a dynamic dimension that represents the loop level j and the last dimension (dimension 5) is a static dimension and allows the ordering of c1 after c0 in the loop nest.</p>
<p>To transform the previous iteration domain to the time-space domain, the following schedule should be used:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]-&gt;c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension called "redundancy ID" is only meaningful if the computation is redundant. i.e., some parts of the computation are redundantly computed. Redundant computations are in general used to maximize parallelism and data locality on the expense of doing some computations redundantly. For example, if the two computations c1(i,j) and c2(i,j) both depend on the computation c0(i,j), instead of waiting for c0(i,j) to be computed and then computing c1(i,j) and c2(i,j) in parallel, the thread executing c1(i,j) can compute c0(i,j) by itself and then run c1(i,j). The thread that computes c2(i,j) can do the same and compute c0(i,j) by itself and then compute c2(i,j). In this case the two threads do not need to wait. This is done at the expense of redundant computation since c0(i,j) is computed by both threads.</p>
<p>In general redundant computations are useful when tiling stencil computations. In the context of stencils such a tiling is called "overlapped tiling". Tiles that depend on results computed by other tiles that run in parallel can compute the boundaries redundantly which allows them to avoid waiting and thus can run in parallel.</p>
<p>In Tiramisu, the user can indicate that a chunk of a computation should be computed redundantly. The original computation always has a redundancy ID equal to 0 (which means this is the original computation). The redundant chunk has an ID that is different from 0 and that is used to uniquely identify it.</p>
<p>For example if we want to compute all of c0 three times (that is, compute the original computation and compute two redundant computations), we can use the following schedules:</p>
<p>The schedule of the original computation: {c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N1: {c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N2: {c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The schedule of c0 in this case would be three maps that map c0[i,j] to the three different redundant computations in the time-processor domain:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The function <a class="el" href="classtiramisu_1_1computation.html#acf43f20d096f8919e93f73facba6c9e6" title="Set the schedule indicated by map. ">set_schedule()</a> overrides any other schedule set by the high level scheduling functions. Currently the user has to choose between using the high level scheduling functions or using this low level set_schedule function. The user cannot mix the use of the two in the same program because they are not compatible. </p>

</div>
</div>
<a class="anchor" id="aa5e50d6910128b7dff0c82ae09ecf9e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_schedule </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>map_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the schedule indicated by <code>map</code>. </p>
<p><code>map</code> is a string that represents a mapping from the iteration domain to the time-space domain (the ISL format to represent maps is documented in <a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> in Sec 1.2.2).</p>
<p>The schedule is a map from the iteration domain to a time space domain. The same name of space should be used for both the range and the domain of the schedule.</p>
<p>In general, users can set the schedule using high level functions such as before(), <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">after()</a>, <a class="el" href="classtiramisu_1_1computation.html#a0fc402b23a4d138cd21eda8e041a8a03" title="Tile the two loop levels L0 and L1 with rectangular tiling. ">tile()</a>, <a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0" title="This function assumes that consumer consumes values produced by this computation (which is the produc...">compute_at()</a>, <a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a>, <a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4" title="Split the loop level L0 of the iteration space into two new loop levels. ">split()</a>, ... The use of this function is only reserved for advanced users who want a low level control of the schedule.</p>
<p>Vectors in the time-space domain have the following form</p>
<p>computation_name[redundancy_ID,static,dynamic,static,dynamic,static,dynamic,static,...]</p>
<p>The first dimension of the vector is used to indicate the redundancy ID (the notion of the redundancy ID is explained later).</p>
<p>The following dimensions are interleaved dimensions: static, dynamic, static, dynamic, ... Dynamic dimensions represent the loop levels, while static dimensions are used to order statements within a given block of statements in a given loop level. For example, the computations c0 and c1 in the following loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N: i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    c0;</div><div class="line">    c1;</div><div class="line">  }</div></div><!-- fragment --><p>have the following representations in the iteration domain</p>
<div class="fragment"><div class="line">{c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and the following representation in the time-space domain</p>
<div class="fragment"><div class="line">{c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension (dimension 0) in the time-space domain (the leftmost dimension) is the redundancy ID (in this case it is 0, the meaning of this ID will be explained later). The second dimension (starting from the left) is a static dimension, the third dimension is a dynamic dimension that represents the loop level i, ..., the fifth dimension is a dynamic dimension that represents the loop level j and the last dimension (dimension 5) is a static dimension and allows the ordering of c1 after c0 in the loop nest.</p>
<p>To transform the previous iteration domain to the time-space domain, the following schedule should be used:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div><div class="line">{c1[i,j]-&gt;c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The first dimension called "redundancy ID" is only meaningful if the computation is redundant. i.e., some parts of the computation are redundantly computed. Redundant computations are in general used to maximize parallelism and data locality on the expense of doing some computations redundantly. For example, if the two computations c1(i,j) and c2(i,j) both depend on the computation c0(i,j), instead of waiting for c0(i,j) to be computed and then computing c1(i,j) and c2(i,j) in parallel, the thread executing c1(i,j) can compute c0(i,j) by itself and then run c1(i,j). The thread that computes c2(i,j) can do the same and compute c0(i,j) by itself and then compute c2(i,j). In this case the two threads do not need to wait. This is done at the expense of redundant computation since c0(i,j) is computed by both threads.</p>
<p>In general redundant computations are useful when tiling stencil computations. In the context of stencils such a tiling is called "overlapped tiling". Tiles that depend on results computed by other tiles that run in parallel can compute the boundaries redundantly which allows them to avoid waiting and thus can run in parallel.</p>
<p>In Tiramisu, the user can indicate that a chunk of a computation should be computed redundantly. The original computation always has a redundancy ID equal to 0 (which means this is the original computation). The redundant chunk has an ID that is different from 0 and that is used to uniquely identify it.</p>
<p>For example if we want to compute all of c0 three times (that is, compute the original computation and compute two redundant computations), we can use the following schedules:</p>
<p>The schedule of the original computation: {c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N1: {c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N2: {c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The schedule of c0 in this case would be three maps that map c0[i,j] to the three different redundant computations in the time-processor domain:</p>
<div class="fragment"><div class="line">{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N;</div><div class="line"> c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>The function <a class="el" href="classtiramisu_1_1computation.html#acf43f20d096f8919e93f73facba6c9e6" title="Set the schedule indicated by map. ">set_schedule()</a> overrides any other schedule set by the high level scheduling functions. Currently the user has to choose between using the high level scheduling functions or using this low level set_schedule function. The user cannot mix the use of the two in the same program because they are not compatible. </p>

</div>
</div>
<a class="anchor" id="a9c24a6e6da57ce6c9b885553c257bf70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_wait_access </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>access_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b9e9e6c4ef9738717202db9e222d81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_wait_access </td>
          <td>(</td>
          <td class="paramtype">isl_map *&#160;</td>
          <td class="paramname"><em>access</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e0c7011fba7e94bb836e7e5f1a55261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the loop level <code>L0</code> of the iteration space by <code>n</code> iterations. </p>
<p><code>n</code> can be a positive or a negative number. A positive number means a shift forward of the loop iterations while a negative value would mean a shift backward. </p>

</div>
</div>
<a class="anchor" id="a792cc56bccec244b942a862800c5589a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>nj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply loop skewing on the loop levels <code>i</code> and <code>j</code> with a skewing factor of <code>f</code>. </p>
<p>The names of the new loop levels is <code>ni</code> and <code>nj</code>.</p>
<p>This command transforms the loop (i, j) into the loop (i, f*i+j). For example if you have the following loop</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; N; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; M; j++)</div><div class="line">    a[i][j] = a[i - 1][j] + a[i][j - 1];</div></div><!-- fragment --><p>and apply</p>
<div class="fragment"><div class="line">a.skew(i, j, 1, ni, nj);</div></div><!-- fragment --><p>you would get</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; N; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i+1; j &lt; i+M; j++)</div><div class="line">    a[i][j - i] = a[i - 1][j - i] + a[i][j - i - 1];</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a80eb1e0a9516089270495fa1f93effda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>nj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>nk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply loop skewing on the loop levels <code>i</code>, <code>j</code> and <code>k</code> with a skewing factor of <code>f</code>. </p>
<p>The names of the new loop levels is <code>ni</code>, <code>nj</code> and <code>nk</code>.</p>
<p>This command transforms the loop (i, j, k) into the loop (i, f*i+j, f*i+k). </p>

</div>
</div>
<a class="anchor" id="a3b457bc242dc982b9ece456a5e5a8e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>nj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>nk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>nl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply loop skewing on the loop levels <code>i</code>, <code>j</code>, <code>k</code>, <code>l</code> with a skewing factor of <code>f</code>. </p>
<p>The names of the new loop levels is <code>ni</code>, <code>nj</code>, <code>nk</code> and <code>nl</code>.</p>
<p>This command transforms the loop (i, j, k, l) into the loop (i, f*i+j, f*i+k, f*i+l). </p>

</div>
</div>
<a class="anchor" id="ac302dac11da3329af21685d91227201f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="adc304a57aa1bd62f1087f48ccfa909a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a97d9b0deb8554546e7b9f68fe33a2747"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a17f8c339f68c5cd8aaf55a483e15b831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a3e7656f0747b1a0aaaa8a68e501a5063"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ade1c710c53696989fcd150c4c7aa2d2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::skew </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a71ba41faf9403d2db864c886db0301d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the loop level <code>L0</code> of the iteration space into two new loop levels. </p>
<p><code>sizeX</code> is the extent (size) of the inner loop created after splitting. </p>

</div>
</div>
<a class="anchor" id="a6781ec005a7e9696b77f06d29d0d8e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the loop level <code>L0</code> of the iteration space into two new loop levels. </p>
<p><code>sizeX</code> is the extent (size) of the inner loop created after splitting. </p>

</div>
</div>
<a class="anchor" id="ab7f5c3c9ca7a9dad31d53936cd268ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to void <a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4" title="Split the loop level L0 of the iteration space into two new loop levels. ">split(tiramisu::var L0, int sizeX)</a>;. </p>

</div>
</div>
<a class="anchor" id="a718678aa2f3dfddc06fbd6760db9c12f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::storage_fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold the storage of the computation. </p>
<p>Fold the loop level <code>dim</code> by a factor <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="ab741d4c5e5dfd5bc0f079fdd681196da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a>* tiramisu::computation::store_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the storage of this computation in the loop level <code>L0</code>. </p>
<p>This function does the following:</p><ul>
<li>computes the size of the buffer needed to store this computation (TODO: current the size computed by Tiramisu is equal to the size of the computation, Tiramisu does not allocate smaller buffers if such a thing is possible, this is left for future work).</li>
<li>allocates a temporary buffer with the appropriate size,</li>
<li>schedules the allocation operation to be executed in the loop nest where <code>comp</code> is computated at the loop level <code>L0</code>.</li>
</ul>
<p>The function returns the computation (operation) that allocates the buffer. The allocated buffer is not returned. </p>

</div>
</div>
<a class="anchor" id="a284f6a8c4a388d15ffa3b40bbfaf5693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::store_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1buffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store this computation in <code>buff</code>. </p>
<p>Let us assume that we have a computation C:</p>
<div class="fragment"><div class="line">{C[i]: 0&lt;=i&lt;N}</div></div><!-- fragment --><p>and that we want to store each C(i) in bufC[i]. Then we can use <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> to indicate that as follows:</p>
<div class="fragment"><div class="line">C.store_in(&amp;bufC)</div></div><!-- fragment --><p>This mans that each computation C(i) will be stored in the buffer location bufC[i].</p>
<p>If <code>iterators</code> is specified, the <code>iterators</code> are used to specify how the computation is mapped to the buffer. If the dimensions of this computation are in0, in1, ..., inn and if <code>iterators</code> are equal to im0, im1, ..., imm then the computation is mapped as follows</p>
<div class="fragment"><div class="line">C[in0, in1, ..., inn]-&gt;bufC[im0, im1, ..., imm].</div></div><!-- fragment --><p>i.e., the computation C[in0, in1, ..., inn] is stored in bufC[im0, im1, ..., imm].</p>
<p>This can be used to store the data in many ways (reordering the storage, storing into modulo buffers, ...).</p>
<p>Assuming we have have computation D(i,j) that has the following iteration domain:</p>
<div class="fragment"><div class="line">{D[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and assuming we have a buffer bufD.</p>
<p>The <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> function can be used to implement many types of data mappings:</p><ul>
<li>Store the computation D to a scalar: D.store_in(&amp;bufD, {}). This mans that D(i) will be stored in bufD[0] (which represents a scalar).</li>
<li>Store a 2 dimensional computation into a 1-dimensional buffer: D.store_in(&amp;bufD, {i});</li>
<li>Change the order of storage. D.store_in(&amp;bufD, {j, i}) will store D(i,j) in bufD(j,i).</li>
<li>Store the computation in a circular buffer (modulo storage). D.store_in(&amp;bufD, {i%4, j%4}); This will store D(i,j) in bufD[i%4, j%4]. Assuming the buffer bufD is a 4x4 buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac9c9d8987709a5b9f19746585dba6a3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::store_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1buffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtiramisu_1_1expr.html">expr</a> &gt;&#160;</td>
          <td class="paramname"><em>iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store this computation in <code>buff</code>. </p>
<p>Let us assume that we have a computation C:</p>
<div class="fragment"><div class="line">{C[i]: 0&lt;=i&lt;N}</div></div><!-- fragment --><p>and that we want to store each C(i) in bufC[i]. Then we can use <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> to indicate that as follows:</p>
<div class="fragment"><div class="line">C.store_in(&amp;bufC)</div></div><!-- fragment --><p>This mans that each computation C(i) will be stored in the buffer location bufC[i].</p>
<p>If <code>iterators</code> is specified, the <code>iterators</code> are used to specify how the computation is mapped to the buffer. If the dimensions of this computation are in0, in1, ..., inn and if <code>iterators</code> are equal to im0, im1, ..., imm then the computation is mapped as follows</p>
<div class="fragment"><div class="line">C[in0, in1, ..., inn]-&gt;bufC[im0, im1, ..., imm].</div></div><!-- fragment --><p>i.e., the computation C[in0, in1, ..., inn] is stored in bufC[im0, im1, ..., imm].</p>
<p>This can be used to store the data in many ways (reordering the storage, storing into modulo buffers, ...).</p>
<p>Assuming we have have computation D(i,j) that has the following iteration domain:</p>
<div class="fragment"><div class="line">{D[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</div></div><!-- fragment --><p>and assuming we have a buffer bufD.</p>
<p>The <a class="el" href="classtiramisu_1_1computation.html#a284f6a8c4a388d15ffa3b40bbfaf5693" title="Store this computation in buff. ">store_in()</a> function can be used to implement many types of data mappings:</p><ul>
<li>Store the computation D to a scalar: D.store_in(&amp;bufD, {}). This mans that D(i) will be stored in bufD[0] (which represents a scalar).</li>
<li>Store a 2 dimensional computation into a 1-dimensional buffer: D.store_in(&amp;bufD, {i});</li>
<li>Change the order of storage. D.store_in(&amp;bufD, {j, i}) will store D(i,j) in bufD(j,i).</li>
<li>Store the computation in a circular buffer (modulo storage). D.store_in(&amp;bufD, {i%4, j%4}); This will store D(i,j) in bufD[i%4, j%4]. Assuming the buffer bufD is a 4x4 buffer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8de3bf0e99741287af84f3af8a4c5365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_distribute_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be distributed. </p>

</div>
</div>
<a class="anchor" id="a38935a2b30a261024a24e6257f6a25b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_distribute_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be distributed. </p>

</div>
</div>
<a class="anchor" id="a12cf0a03413b4be996c62c1ea61f5d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_gpu_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU. </p>

</div>
</div>
<a class="anchor" id="ae4fb03cd144ca7282b5fbcf3a5aeb32e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_gpu_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU. </p>

</div>
</div>
<a class="anchor" id="ab21a3469f5925d109b1f850ea9a9dd57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_gpu_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU. </p>

</div>
</div>
<a class="anchor" id="a37ba81bf0611bb2f058ae7659fefd561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_parallel_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be parallelized. </p>

</div>
</div>
<a class="anchor" id="aa1791e78809423426079f5063dfb8229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_parallel_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to void <a class="el" href="classtiramisu_1_1computation.html#aa1791e78809423426079f5063dfb8229" title="Identical to void tag_parallel_level(int L);. ">tag_parallel_level(int L)</a>;. </p>

</div>
</div>
<a class="anchor" id="a2ab7d0d28bfc5cef46d45483bc1c6385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_unroll_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be unrolled. </p>
<p>The user can only tag loop levels that have constant extent. </p>

</div>
</div>
<a class="anchor" id="a72c8deb246b1df5e86da2b8cd0402ff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_unroll_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to void <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level(tiramisu::var L)</a>;. </p>

</div>
</div>
<a class="anchor" id="a6b1c88a897e6ebd7c6e9b7bf0a35c963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_vector_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be vectorized. </p>
<p><code>len</code> is the vector length.</p>
<p>The user can only tag loop levels that have constant extent. If a loop level does not have a constant extent, the user should call .<a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a> command instead or he can call separate() and <a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4" title="Split the loop level L0 of the iteration space into two new loop levels. ">split()</a> manually.</p>
<p>The user has to make sure that the extent of the dimension is bigger than <code>len</code>. The vectorization of a loop that has less than <code>len</code> iterations is not correct. </p>

</div>
</div>
<a class="anchor" id="a1e11c118fc21f59a2bc60be2b932baba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_vector_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to void <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level(tiramisu::var L, int len)</a>;. </p>

</div>
</div>
<a class="anchor" id="aa5fd9fb1ba61cae4576a39f189b46b5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">computation</a>&amp; tiramisu::computation::then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>next_computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run before the computation <code>next_computation</code> at the loop level <code>L</code> and return <code>next_computation</code>. </p>
<p>Notes</p><ul>
<li>This method is a simple wrapper around <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">computation::after</a> to help schedule chaining as in: <div class="fragment"><div class="line">C1.then(C2, j)</div><div class="line">  .then(C3, <a class="code" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc">computation::root</a>)</div><div class="line">  .then(C4, i)</div><div class="line">  .then(C5, j);</div></div><!-- fragment --></li>
<li>The loop level <code>L</code> is a loop level of this computation.</li>
<li>Use <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> to indicate the root dimension (i.e. the outermost time-space dimension).</li>
<li>Calling this method with the same computations overwrites the level if it is higher.</li>
<li>A computation being scheduled after another computation at level L means it is scheduled after that computation at all levels lower than L. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0fc402b23a4d138cd21eda8e041a8a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a class="anchor" id="a5a63c66e3db24bd85b1ffe7b23822c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a class="anchor" id="ae37bc997ad3dacfd4bea812c068b87ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a class="anchor" id="a8b17318417cb0d0419f66bf8fb742246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a class="anchor" id="adf6cd1724b02fa9bfc79dd903ec8af57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels (i.e., <code>L0</code> = <code>L1</code> + 1) and they should satisfy <code>L0</code> &gt; <code>L1</code>. </p>

</div>
</div>
<a class="anchor" id="a453a8ec8ce2cfba365da5d5b1f659cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels (i.e., <code>L0</code> = <code>L1</code> + 1) and they should satisfy <code>L0</code> &gt; <code>L1</code>. </p>

</div>
</div>
<a class="anchor" id="a68cc2dc757dfb181548b739c901ed6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>. </p>
<p>The difference between this function and the function <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level()</a> is that this function separates the iteration domain into full and partial iteration domains for unrolling first and then it calls <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level()</a>. <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level()</a> only tags a dimension to be unrolled, it does not modify the tagged dimension.</p>
<p>This function separates the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>fac</code> while the other does not. The full iteration domain is then split by <code>fac</code> and the inner loop (which should have a constant extent equal to <code>fac</code>) is tagged as a unrolled loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;23; j++)</div><div class="line">    S0;</div></div><!-- fragment --><p>To unroll the j loop with an unrolling factor of 4, one should call </p><pre class="fragment"> S0.unroll(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;20; i++)</div><div class="line">  S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>The full loop is then split by 4</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i1=0; i1&lt;20/4; i1++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2=0; i2&lt;4; i2++)</div><div class="line">     S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>the i2 loop is then tagged to be unrolled.</p>
<p><code>L_outer</code> and <code>L_inner</code> are the names of the new loops created after splitting. If not provided, default names will be assigned. <code>L_outer</code> is the outer loop. </p>

</div>
</div>
<a class="anchor" id="a566d1284eef9d999112660a3fff30561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>. </p>
<p>The difference between this function and the function <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level()</a> is that this function separates the iteration domain into full and partial iteration domains for unrolling first and then it calls <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level()</a>. <a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385" title="Tag the loop level L to be unrolled. ">tag_unroll_level()</a> only tags a dimension to be unrolled, it does not modify the tagged dimension.</p>
<p>This function separates the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>fac</code> while the other does not. The full iteration domain is then split by <code>fac</code> and the inner loop (which should have a constant extent equal to <code>fac</code>) is tagged as a unrolled loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;23; j++)</div><div class="line">    S0;</div></div><!-- fragment --><p>To unroll the j loop with an unrolling factor of 4, one should call </p><pre class="fragment"> S0.unroll(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;20; i++)</div><div class="line">  S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>The full loop is then split by 4</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i1=0; i1&lt;20/4; i1++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2=0; i2&lt;4; i2++)</div><div class="line">     S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>the i2 loop is then tagged to be unrolled.</p>
<p><code>L_outer</code> and <code>L_inner</code> are the names of the new loops created after splitting. If not provided, default names will be assigned. <code>L_outer</code> is the outer loop. </p>

</div>
</div>
<a class="anchor" id="a7afeafbe16b09b6b2a8f58d00ce3870b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::unschedule_this_computation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't scheduled a previously scheduled computation. </p>

</div>
</div>
<a class="anchor" id="abfb52d2e77fd1157343350a01fe905ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorize the loop level <code>L</code>. </p>
<p>Use the vector length <code>v</code>.</p>
<p>The difference between this function and the function <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level()</a> is that this function prepares the iteration domain for vectorization first and then it calls <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level()</a>. <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level()</a> only tags a dimension to be vectorized, it does not change the tagged dimension.</p>
<p>This function will separate the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>v</code> while the other does not. The full iteration domain is then split by <code>v</code> and the inner loop (which should have a constant extent equal to <code>v</code>) is tagged as a vector loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;23; j++)</div><div class="line">    S0;</div></div><!-- fragment --><p>To vectorize the j loop with a vector length 4, one should call </p><pre class="fragment"> S0.vectorize(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;20; i++)</div><div class="line">  S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>The full loop is then split by 4</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i1=0; i1&lt;20/4; i1++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2=0; i2&lt;4; i2++)</div><div class="line">     S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>the i2 loop is then tagged to be vectorized.</p>
<p>The user has to make sure that the extent of the dimension is bigger than <code>v</code>. The vectorization of a loop that has less than <code>v</code> iterations is not correct.</p>
<p>The names of the new loop iterators created after vectorization are <code>L_outer</code> and <code>L_inner</code>. If not provided, default names assigned. </p>

</div>
</div>
<a class="anchor" id="ac7f4dd685fd931af56ba633fef4b184b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorize the loop level <code>L</code>. </p>
<p>Use the vector length <code>v</code>.</p>
<p>The difference between this function and the function <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level()</a> is that this function prepares the iteration domain for vectorization first and then it calls <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level()</a>. <a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963" title="Tag the loop level L to be vectorized. ">tag_vector_level()</a> only tags a dimension to be vectorized, it does not change the tagged dimension.</p>
<p>This function will separate the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>v</code> while the other does not. The full iteration domain is then split by <code>v</code> and the inner loop (which should have a constant extent equal to <code>v</code>) is tagged as a vector loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;23; j++)</div><div class="line">    S0;</div></div><!-- fragment --><p>To vectorize the j loop with a vector length 4, one should call </p><pre class="fragment"> S0.vectorize(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;20; i++)</div><div class="line">  S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>The full loop is then split by 4</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i1=0; i1&lt;20/4; i1++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2=0; i2&lt;4; i2++)</div><div class="line">     S0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=20; i&lt;23; i++)</div><div class="line">  S0;</div></div><!-- fragment --><p>the i2 loop is then tagged to be vectorized.</p>
<p>The user has to make sure that the extent of the dimension is bigger than <code>v</code>. The vectorization of a loop that has less than <code>v</code> iterations is not correct.</p>
<p>The names of the new loop iterators created after vectorization are <code>L_outer</code> and <code>L_inner</code>. If not provided, default names assigned. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8aae053de52966a72d5faee3a75662c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::computation::_is_library_call</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this computation represents a library call. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l02274">2274</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40c98b7f222724166710f4718592d90c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tiramisu::computation::library_call_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the computation represents a library call, this is the name of the function. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l02279">2279</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b874384f567f7bbf60bbf58f86e6ddc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtiramisu_1_1var.html">var</a> tiramisu::computation::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>root_dimension is a number used to specify the dimension level known as root. </p>
<p>The root dimension level is the outermost level. It is the level outside any loop nest. Loop level 0 is the level of the first loop (outermost loop), loop 1 is the level of following inner loop, ...</p>
<p>Where is this number used ?</p>
<p>These numbers are used in the helper functions used for scheduling (such as <a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d" title="Schedule this computation to run after the computation comp. ">after()</a>, before(), ...). For example, c0.after(c1) indicates that the computation c0 should be executed after the computation c1. Since the two computations c0 and c1 are usually nested in a loop, we need to specify at which loop level c0 is after c1. This is where we need to specify the loop level numbers. Here is an example. Suppose that the two computations c0 and c1 have the following iteration domains {c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}.</p>
<p>When code is generated for the two computations, two loop nests are generated. When scheduling c0 after c1 using the after function, the user can choose one among three possibilities in specifying at which level c0 is after c1.</p>
<ul>
<li>c0.after(c1, computation::root_dimension) would create a schedule that generates the following code</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        c1;</div><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        c0;</div></div><!-- fragment --><ul>
<li>c0.after(c1, 0) would create a schedule that generates the following code</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++) {</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        c1;</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        c0;</div><div class="line">}</div></div><!-- fragment --><p>This means that c0 is after c1 starting from loop level 0, (before the loop level 0, c0 and c1 have the same order).</p>
<ul>
<li>c0.after(c1, 1) would create a schedule that generates the following code</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++) {</div><div class="line">        c1;</div><div class="line">        c0;</div><div class="line">    }</div></div><!-- fragment --><p>This means that c0 is after c1 starting from loop level 1, (before the loop level 1, c0 and c1 have the same order). </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l03990">3990</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab8e56982ea734feb3dc1670969ff617d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int tiramisu::computation::root_dimension = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent of <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> but to be used with scheduling functions that take loop level (integers) as input instead of <a class="el" href="classtiramisu_1_1var.html" title="A class that represents constant variable references. ">tiramisu::var</a>. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l03997">3997</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d1db85e39c0d9db0d4edf4209164dfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_ast_expr* tiramisu::computation::wait_index_expr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An index expression just for the request buffer. </p>

<p>Definition at line <a class="el" href="core_8h_source.html#l02284">2284</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="core_8h_source.html">core.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetiramisu.html">tiramisu</a></li><li class="navelem"><a class="el" href="classtiramisu_1_1computation.html">computation</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
